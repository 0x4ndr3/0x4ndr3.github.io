<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D;--font-size:1.1rem}</style><title>Starting dynamic analysis on a Windows x64 rootkit</title><meta name=description content="
Starting dynamic analysis on a Windows x64 rootkit
In this blog post, we will be operating under the assumption that you have retrieved a Windows kernel …"><meta name=keywords content='blog,gokarna,hugo'><meta property="og:url" content="https://0x4ndr3.github.io/posts/starting-dynamic-analysis-on-a-windows-x64-rootkit/"><meta property="og:type" content="website"><meta property="og:title" content="Starting dynamic analysis on a Windows x64 rootkit"><meta property="og:description" content="
Starting dynamic analysis on a Windows x64 rootkit
In this blog post, we will be operating under the assumption that you have retrieved a Windows kernel …"><meta property="og:image" content="https://0x4ndr3.github.io/posts/starting-dynamic-analysis-on-a-windows-x64-rootkit/images/17.png"><meta property="og:image:secure_url" content="https://0x4ndr3.github.io/posts/starting-dynamic-analysis-on-a-windows-x64-rootkit/images/17.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Starting dynamic analysis on a Windows x64 rootkit"><meta name=twitter:description content="
Starting dynamic analysis on a Windows x64 rootkit
In this blog post, we will be operating under the assumption that you have retrieved a Windows kernel …"><meta property="twitter:domain" content="https://0x4ndr3.github.io/posts/starting-dynamic-analysis-on-a-windows-x64-rootkit/"><meta property="twitter:url" content="https://0x4ndr3.github.io/posts/starting-dynamic-analysis-on-a-windows-x64-rootkit/"><meta name=twitter:image content="https://0x4ndr3.github.io/posts/starting-dynamic-analysis-on-a-windows-x64-rootkit/images/17.png"><link rel=canonical href=https://0x4ndr3.github.io/posts/starting-dynamic-analysis-on-a-windows-x64-rootkit/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.fdbfba1e074acb7e4abbf4c94eb19abb7702489c9689a27ee5e24a2bd481e4b7.js integrity="sha256-/b+6HgdKy35Ku/TJTrGau3cCSJyWiaJ+5eJKK9SB5Lc="></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://0x4ndr3.github.io/><img src=https://0x4ndr3.github.io/main.png alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://0x4ndr3.github.io/>0x4ndr3</a></div><div class=nav-links><div class=nav-link><a href=https://0x4ndr3.github.io/posts/ aria-label><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></div><div class=nav-link><a href=https://github.com/0x4ndr3 aria-label=github target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://0x4ndr3.github.io/posts/><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></li><li class=nav-item><a href=https://github.com/0x4ndr3 target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>Starting dynamic analysis on a Windows x64 rootkit</h1><small role=doc-subtitle></small><p class=post-date>May 23, 2022</p><ul class=post-tags></ul></div><div class=post-content><p><img src=images/17.png alt=17></p><p><strong>Starting dynamic analysis on a Windows x64 rootkit</strong></p><p>In this blog post, we will be operating under the assumption that you have retrieved a Windows kernel rootkit sample and want to breakpoint into the DriverEntry function, which is the equivalent of the *main *function in a normal executable file, but for the rootkit/driver. This might seem straight forward, and it is when you have the source code (technique #1) or the symbols for the payload (technique #2), but it’s not as straight-forward when you don’t have either (technique #3). The latter is typically the case when you need to analyze a malicious sample.</p><p><strong>The lab and the sample</strong></p><p>I’m doing remote kernel debugging which means I have a host Operating System (OS) and a target OS (Windows 10 version 22000, aka Windows 11) which is a Virtual Machine (VM).</p><p><img src=images/01.png alt=01></p><p>This specific OS has some peculiarities when it comes to installing it in a VM, which I’ll point out next.</p><p>This is not meant to be a walk-through the entire lab as it would become a blog post in itself. I’m only pointing out a few quirks on the setup. If you want to go deeper into the topic, I’d recommend the following, all by <a href=https://twitter.com/zodiacon/ target=_blank rel="nofollow noopener noreferrer"><span>Pavel Yosifovich
</span></a>:</p><ul><li><a href=https://leanpub.com/windowskernelprogramming target=_blank rel="nofollow noopener noreferrer"><span>Windows Kernel Programming</span></a></li><li>&ldquo;<a href=https://my.ine.com/CyberSecurity/courses/d5e1d053/windows-kernel-programming-fundamentals target=_blank rel="nofollow noopener noreferrer">
<span>Windows Kernel Programming: Fundamentals
</span></a>&rdquo; video course @ INE</li></ul><p>The virtualization software I’m using is VMware Workstation 16 Pro and the VM settings are the following:</p><p><img src=images/02.png alt=02></p><p>This is relevant if your target OS is Windows 11, which must follow <a href=https://www.microsoft.com/en-us/windows/windows-11-specifications target=_blank rel="nofollow noopener noreferrer">
<span>a few requirements
</span></a>. When installing the OS, you’ll need to encrypt the VM, and add the Trusted Platform Module (TPM):</p><p><img src=images/03.png alt=03></p><p><img src=images/04.png alt=04></p><p>Now, while I did have the secure boot option enabled (bottom right of the screenshot below), when installing the OS, I did have to disable it in order to set up Windows debug mode.</p><p><img src=images/05.png alt=05></p><p>To set this up, in the target VM, you need to run the following commands:</p><blockquote><p> <em>bcdedit -debug on</em></p></blockquote><p>As mentioned earlier, this requires secure mode to be disabled, and it should be followed by a reboot.</p><p>From here on, it’s “business as usual” in terms of setting up the environment:</p><blockquote><p> <em>bcdedit /dbgsettings net hostip:&lt;ip> port:&lt;port></em></p></blockquote><blockquote><p> <em>bcdedit /set testsigning on</em></p></blockquote><p>At this point, I’m using <a href=https://www.microsoft.com/en-gb/p/windbg-preview/9pgjgd53tn86 target=_blank rel="nofollow noopener noreferrer">
<span>Windbg Preview
</span></a> to get the connection from the target OS.</p><p>Regarding the <a href=https://github.com/0x4ndr3/mycontent/blob/main/2022/PwC/Blog01/Sample.cpp target=_blank rel="nofollow noopener noreferrer">
<span>sample code
</span></a>, this is it:</p><p><img src=images/06.png alt=06></p><p>Technically, I could’ve simplified the code even more by not having the unload function, but it’s useful to unload and load the driver multiple times in the lab.</p><p><strong>Technique #1: __debugbreak()</strong></p><p>As mentioned at the start, this is a very easy way to break at the beginning of the rootkit/driver. However, it assumes you have the source code.</p><p>This is quite useful if you’re testing your own code but next to useless if it’s malware you’re analyzing. This is due to the fact that whenever you retrieve a sample to reverse engineer, they pretty much never come with the source code.</p><p>So, how to go about it? Pretty straight-forward. You add the line “__debugbreak()” to wherever you wish to stop in the code and the execution stops there.</p><p><img src=images/07.png alt=07></p><p>Recompile, move the <a href=https://github.com/0x4ndr3/mycontent/blob/main/2022/PwC/Blog01/Sample.sys target=_blank rel="nofollow noopener noreferrer">
<span>.sys file
</span></a> into the target OS, and load the driver:</p><p><img src=images/08.png alt=08></p><p>Right after typing enter, on the last line, the OS freezes and when you move back to Windbg the debugger has stopped exactly where you want it.</p><p><img src=images/09.png alt=09></p><p><img src=images/10.png alt=10></p><p><strong>Technique #2: sxe</strong></p><p>When “<a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/sx--sxd--sxe--sxi--sxn--sxr--sx---set-exceptions- target=_blank rel="nofollow noopener noreferrer">
<span>Set eXceptions Enable
</span></a>” (sxe) occurs, the target immediately breaks into the debugger before any other error handlers are activated. This kind of handling is called first chance handling.</p><p>More specifically, what we want to execute at Windbg is:</p><blockquote><p>sxe ld:Sample.sys</p></blockquote><p>The “ld” stands for “load” and it’s relative to a module. This means that the break occurs when a module with this name is loaded.</p><p>To test this, we’ll revert back to the <a href=https://github.com/0x4ndr3/mycontent/blob/main/2022/PwC/Blog01/Sample.cpp target=_blank rel="nofollow noopener noreferrer">
<span>original simplified source code
</span></a> (without “__debugbreak()”), and we’ll also need the <a href=https://github.com/0x4ndr3/mycontent/blob/main/2022/PwC/Blog01/Sample.pdb target=_blank rel="nofollow noopener noreferrer">
<span>PDB file
</span></a> alongside the <a href=https://github.com/0x4ndr3/mycontent/blob/main/2022/PwC/Blog01/Sample.sys target=_blank rel="nofollow noopener noreferrer">
<span>driver/rootkit sample
</span></a>. This is the disadvantage of using this technique as it is quite unrealistic to expect the analyst to have the matching <a href="https://docs.microsoft.com/en-us/windows/win32/debug/symbol-files?redirectedfrom=MSDN" target=_blank rel="nofollow noopener noreferrer">
<span>PDB file
</span></a> when analyzing malware.</p><p>We then set the first chance exception for the load event relative to the module <em>Sample.sys</em>:</p><p><img src=images/11.png alt=11></p><p>Then we load the driver/rootkit and the system will once again freeze, and we can move on with our analysis within the debugger.</p><p><img src=images/12.png alt=12></p><p><img src=images/13.png alt=13></p><p>If we look at the modules loaded (<em>lm</em> command) we can see the Virtual Address (VA) where the module has been placed in memory, and then use that as input to the “<em>dh</em>” (display header) extension command, which will interpret the Portable Executable (PE) file format and give us the entry point.</p><p><img src=images/14.png alt=14></p><p>The entry point for a driver looks like the following (function “<em>start</em>” if you open a driver/rootkit with IDA) and will have two *call *instructions. The first sets up the stack cookie (GS option is the default in the compilation process these days) and the second one is the *DriverEntry *which is the actual entry point from the programmer’s perspective.</p><p><img src=images/15.png alt=15></p><p>At this point all you need to do is set a breakpoint at that *call *instruction and step into it.</p><p>This scenario, as mentioned previously, is very unlikely though.</p><p><strong>Technique #3: IopLoadDriver or IopInitializeBuiltinDriver</strong></p><p>This one is the most reliable techniques in order to start the dynamic analysis procedure on a rootkit/driver. It consists of breaking at specific API functions which are used to load drivers in general, and navigate your way through a series of indirect calls and conditional jumps until you reach the DriverEntry() function.</p><p>So the first question is: which API function is responsible for this?</p><p>The answer can be retrieved from some analysis using for example technique #1, described previously, with the __debugbreak().</p><p><img src=images/16.png alt=16></p><p><img src=images/17.png alt=17></p><p>After loading the driver and breaking at the start of <em>DriverEntry</em>, we can run a <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/k--kb--kc--kd--kp--kp--kv--display-stack-backtrace- target=_blank rel="nofollow noopener noreferrer">
<span>stack backtrace
</span></a> and see what’s being done by the Operating System.</p><p><img src=images/18.png alt=18></p><p>We could actually set a breakpoint at <em>PnpCallDriverEntry</em> (the first call that is not part of our module/rootkit/driver), but we’ll start from <em>IopLoadDriver</em> as it’s actually the one responsible for the loading and is consistent throughout older versions of Windows. Windows XP SP3, for example, had <em>MmLoadSystemImage</em> instead of <em>PnpCallDriverEntry</em>. But in Windows 11, our target OS, you could definitely start this process at <em>PnpCallDriverEntry</em>.</p><p>The <em>IopInitializeBuiltinDriver</em> is invoked to execute the same functionality as <em>IopLoadDriver</em>, but for built-in drivers.</p><p>So now that we know where to put the breakpoint, let’s do so, but on the <a href=https://github.com/0x4ndr3/mycontent/blob/main/2022/PwC/Blog01/Sample.sys target=_blank rel="nofollow noopener noreferrer">
<span>driver
</span></a> without the __debugbreak() to simulate a real-world scenario, and go from there.</p><p><img src=images/19.png alt=19></p><p><img src=images/20.png alt=20></p><p>After these, the breakpoint is hit.</p><p><img src=images/21.png alt=21></p><p>You should confirm this is the right <em>IopDriverLoad</em> as it could be possible that something else loads a driver at around the same time as you are doing so.</p><p>As it’s been reversed by the <a href=https://doxygen.reactos.org/d9/d9f/ntoskrnl_2io_2iomgr_2driver_8c.html#a1b5a2c0ea74ed8b816eef35731cb268e target=_blank rel="nofollow noopener noreferrer">
<span>ReactOS team
</span></a> and many others, the first parameter to the function is a handle to the registry key of the driver, which will give out its name, and our confirmation that it’s the right driver loading.</p><p><img src=images/22.png alt=22></p><p>Now this function is quite big, so we’ll print out only the <em>call</em> instructions as we already know which specific *call *we are looking for: <em>PnPCallDriverEntry</em>, as per the previous stack backtrace.</p><p><img src=images/23.png alt=23></p><p>Going down the list, we eventually find what we are looking for.</p><p><img src=images/24.png alt=24></p><p>Next, we can step into it and then step into the second “call” instruction.</p><p><img src=images/25.png alt=25></p><p>If you were trying to make sense out of this and reversing this code from the beginning, you could look into the calls being made:</p><p><img src=images/26.png alt=26></p><p>The first one is enabling Windows watchdog, a timer that is used to detect hardware or software lockups by counting down to zero. If it reaches zero, it will assume the system has frozen and will take corrective action. So it’s clearly not the <em>call</em> we are interested in. The ones after the second one seem to start a bunch of cleanup tasks, including deleting timers, and releasing dynamically allocated memory. So the second <em>call</em> would be a good bet regarding something interesting happening, as in, identifying where the <em>DriverEntry</em> function is located.</p><p>After stepping into the second <em>call</em>, it’s a matter of looking around until you realize where exactly to go from there on.</p><p>The <em>jump if equal</em> instruction will take you to the next step.</p><p><img src=images/27.png alt=27></p><p>After that jump, we find another one.</p><p><img src=images/28.png alt=28></p><p>And, finally, we get into the entry point of our module/rootkit/driver. Looking into the <em>rax</em> register, we can recognize from previous analysis, the 5000h offset (offset to the entry point).</p><p><img src=images/29.png alt=29></p><p><img src=images/30.png alt=30></p><p><img src=images/31.png alt=31></p><p><strong>Then what?</strong></p><p>At this point, it’s usually up to each person’s preference, but it would be a good idea to run static analysis first, so you can get a general idea of what’s happening, and then synchronize the dynamic and static analysis to take advantage of each tool’s strengths.</p><p>So I’d definitely start IDA (or whatever tool you prefer), open the <em>start</em> function, and rebase the program (Edit > Segments > Rebase program…) to have the VA addresses match on both IDA and Windbg.</p><p><img src=images/32.png alt=32></p><p><img src=images/33.png alt=33></p><p>At this point, after a few sessions in Windbg, we can tell that the second <em>call</em> is the <em>DriverEntry</em>.</p><p><img src=images/34.png alt=34></p><p><img src=images/35.png alt=35></p><p>From here on it’s reversing as usual: renaming functions and local variables, setting software or hardware breakpoints, and figuring it all out. Not quite comparable though with a normal exe/dll, as drivers do have distinguishing features and analyzing them does require some level of knowledge regarding Windows Internals.</p><p>But at least you know how to start now :)</p></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div></main><footer class=footer><span>&copy; 2022 Andre Lima</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/gokarna-theme/gokarna-hugo>Gokarna</a></span></footer></body></html>