<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D;--font-size:1.1rem}</style><title>x64 Egg hunting in Linux systems</title><meta name=description content="There isn’t much when it comes to egg hunters, and even less when it comes to x64 ones. And the ones out there on exploit-dband shell-stormdo leave a lot to …"><meta name=keywords content='blog,gokarna,hugo'><meta property="og:url" content="https://0x4ndr3.github.io/posts/x64-egg-hunting-in-linux-systems/"><meta property="og:type" content="website"><meta property="og:title" content="x64 Egg hunting in Linux systems"><meta property="og:description" content="There isn’t much when it comes to egg hunters, and even less when it comes to x64 ones. And the ones out there on exploit-dband shell-stormdo leave a lot to …"><meta property="og:image" content="https://0x4ndr3.github.io/main.png"><meta property="og:image:secure_url" content="https://0x4ndr3.github.io/main.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="x64 Egg hunting in Linux systems"><meta name=twitter:description content="There isn’t much when it comes to egg hunters, and even less when it comes to x64 ones. And the ones out there on exploit-dband shell-stormdo leave a lot to …"><meta property="twitter:domain" content="https://0x4ndr3.github.io/posts/x64-egg-hunting-in-linux-systems/"><meta property="twitter:url" content="https://0x4ndr3.github.io/posts/x64-egg-hunting-in-linux-systems/"><meta name=twitter:image content="https://0x4ndr3.github.io/main.png"><link rel=canonical href=https://0x4ndr3.github.io/posts/x64-egg-hunting-in-linux-systems/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.fdbfba1e074acb7e4abbf4c94eb19abb7702489c9689a27ee5e24a2bd481e4b7.js integrity="sha256-/b+6HgdKy35Ku/TJTrGau3cCSJyWiaJ+5eJKK9SB5Lc="></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://0x4ndr3.github.io/><img src=https://0x4ndr3.github.io/main.png alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://0x4ndr3.github.io/>0x4ndr3</a></div><div class=nav-links><div class=nav-link><a href=https://0x4ndr3.github.io/posts/ aria-label><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></div><div class=nav-link><a href=https://github.com/0x4ndr3 aria-label=github target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://0x4ndr3.github.io/posts/><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></li><li class=nav-item><a href=https://github.com/0x4ndr3 target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>x64 Egg hunting in Linux systems</h1><small role=doc-subtitle></small><p class=post-date>November 24, 2017</p><ul class=post-tags></ul></div><div class=post-content><p>There isn’t much when it comes to egg hunters, and even less when it comes to x64 ones. And the ones out there on <a href=https://www.exploit-db.com/shellcode target=_blank rel="nofollow noopener noreferrer"><span>exploit-db
</span></a>and <a href=http://shell-storm.org/shellcode/ target=_blank rel="nofollow noopener noreferrer"><span>shell-storm
</span></a> do leave a lot to be explained, and some… let’s just say I can’t imagine the authors even bothered to test them, let alone read Skape’s paper on <a href=http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf target=_blank rel="nofollow noopener noreferrer">
<span>Safely Searching Process Virtual Address Space
</span></a>. Fortunately, Skape’s paper exists and, together with a <a href=https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf target=_blank rel="nofollow noopener noreferrer"><span>lot of reading
</span></a> … and <a href=https://static.lwn.net/images/pdf/LDD3/ch15.pdf target=_blank rel="nofollow noopener noreferrer"><span>some more reading
</span></a>, on memory models, virtual address space, etc, I hope to be able to explain this in the simplest of ways.</p><p>So, what’s an egg hunter? It’s basically a very short shellcode which has a single purpose: locate a longer shellcode somewhere else in memory and execute it. There are instances of <a href="https://www.corelan.be/?s=exploit+writing+tutorial&amp;search=Search" target=_blank rel="nofollow noopener noreferrer"><span>buffer overflow
</span></a>exploitation, where you’ll be extremely limited in terms of buffer space. In these specific cases, you may need an egg hunter if you can also put in the longer shellcode elsewhere to be found and executed.</p><h2 id=searching-the-memory>Searching the memory</h2><p>There are a lot of details in terms of memory implementation by the Operating System and the CPU architecture. That is beyond scope, and I’ll be addressing only the parts that will impact the code.</p><p>From the egg hunting perspective, the important thing to know is how the memory is presented to the process. And that’s through what’s called Virtual Address Space (VAS). By default, the 64-bit VAS has the following structure:</p><p><img src=images/fig112.png alt="Figure 1 – Memory as seen by a process"></p><p>If you want to go into the details of why is it organised as such, how is the mapping done to real addresses, paging, etc, look into section 3.3 of the <a href=https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf target=_blank rel="nofollow noopener noreferrer"><span>Intel’s manual
</span></a>. Suffice to say that, for performance purposes, current (and foreseeable future) address space implementations only use 48 bits (realistically more than enough in our times) out of the 64. The 48th bit (position 47) is extended to the rest of the left bits, hence creating a range of unused positions, the so-called “canonical hole” in figure 1.</p><p>Now this is great news actually, because we now realise we don’t have to look from position zero (first byte in memory – VAS) to position 0xffffffffffffffff (64-bit all 1’s). We just have to search for the egg inside the user space. Now the questions are: do I have to look for it in all user space? Is there a faster way to do it?</p><p>The user space (green section in figure 1) memory structure goes as follows:</p><blockquote><p>0x00007fffffffffff<br>User stack<br>|<br>v<br>Memory mapped region for shared libraries or anything else<br>^<br>|<br>Heap<br>Uninitialised data (.bss)<br>Initialised data (.data)<br>Program text (.text)<br>0x0000000000000000</p></blockquote><p>It’s made out of regions/sections with different access permissions. Let’s look into this in an example.</p><p>I wrote the following code:</p><p><img src=images/fig23.png alt="Figure 2 – test.nasm demo code"></p><p>After compiling (<em># nasm -f elf64 test.nasm -o test.o && ld -o test test.o</em>) and executing it, it’ll hang on the read syscall, keeping it running while waiting for me to attach to it with GDB.</p><p><img src=images/fig35.png alt="Figure 3 – PID and section listing"></p><p>To attach to it, I need the PID, which I’m getting at figure 3, and I’m also executing “<em>cat proc//maps”</em> so I can see the sections. Now, there are other ways (“pmap”, and “info proc mappings” inside GDB) with which I can get the sections listing, but only the “<em>cat proc/…”</em> method gives me the permissions (read, write, execute, private, shared) the process has on the sections, which I want to show you for the purpose of this exercise.</p><p>This is a small assembly application (no external libraries), so it has few sections, and we won’t find any non-readable ones. I could integrate a glibc call (ex: printf, scanf, exit) into the application and compile it with gcc instead of ld, to show a non-readable section (.so files) example, but the exception I want to show, is also triggered when trying to write to a section you don’t have write permissions to, so for the sake of simplicity, I’ll stick to this one.</p><p>We now attach to the PID using GDB, set RSP with a value belonging to the range of section VDSO, as seen in figure 3, and try to write into it.</p><p><img src=images/fig42.png alt="Figure 4 – Segmentation fault"></p><p>So figure 4’s write attempt results in a segmentation fault. This happens whenever the process tries to access (read/write/execute) positions in memory it does not have the corresponding permission to.</p><p><strong>And that is why you cannot simply iterate through the whole user space.</strong> This interrupt signal (SIGSEGV) would break your egg hunter and render it useless.</p><p>Note that there are a few egg hunters that do exactly that, but I’ll go through this choice and why it (sometimes) works, at the end of this post.</p><p>One last detail about memory: pages. Every section/region is made out of multiple pages, which are continuous fixed-length blocks of memory. Memory is allocated in chunks of these page units, and <strong>this is important for us</strong> because if you can’t access a memory address in a page, there’s no point on continuing testing the following positions in the same page, since they’ll either be not allocated, or you’ll have the same permission issues because all permissions are the same in a page. This will make the search algorithm faster.</p><p>If you look at figure 3, you’ll realise that the start and end addresses (in hex) are all multiples of 4096, as the lower 12 bits are always zeroed. For example, even though the application’s code is less then 4096 bytes, the section it’s in, still is exactly 4096 bytes in size (from 0x00400000 to 0x00401000).</p><p>But how can I be sure the page size is actually 4096?</p><p><img src=images/fig51.png alt="Figure 5 – checking the page size (also works by checking PAGE_SIZE)"></p><h2 id=the-egg-hunter-first-attempt>The egg hunter, first attempt</h2><p>Usually, at this point, I’d go for the obvious solution to the SIGSEGV problem: setting up an interrupt handler because that’s what SIGSEGV is: an interrupt signal. But it’s pretty obvious it would result in a long (relatively speaking) code, which ruins the whole purpose of the egg hunter. Besides, <a href=http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf target=_blank rel="nofollow noopener noreferrer"><span>Skape
</span></a>tried it and the same conclusion was reached.</p><p>So, we’ll definitely have to search through memory, but we still have the SIGSEGV issue to deal with. To address it, <a href=http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf target=_blank rel="nofollow noopener noreferrer"><span>Skape shows us three solutions
</span></a>, by basically using syscalls that will return a clear indication (EFAULT = -14 = 0xfffffffffffffff2) that we do not have permissions to access the given memory position.</p><p><strong>I then thought about trying a syscall other than the ones proposed by Skape</strong> (__NR_access and __NR_rt_sigaction). And the write (__NR_write) syscall went through my mind. It’s used to print text into the screen and for it to know what we want to print, it requires a buffer as the 2nd parameter (RSI). So I wrote the following test code:</p><p><img src=images/fig61.png alt="Figure 6 – addressing unauthorised memory position with write syscall"></p><p>And when testing it, for address position 0x1000, it returned the EFAULT (0xfffffffffffffff2) as I was hoping for.</p><p><img src=images/fig72.png alt="Figure 7 – testing return address of write syscall when addressing unauthorised memory positions"></p><p>This made me hopeful… until I actually wrote the egg hunter code, and while it did work when I positioned the first address at the section where the real payload is located, it didn’t work so well in other more generic scenarios. Specifically, it didn’t return EFAULT when it was supposed to and then “broke” (SIGSEGV) when trying to fetch the four bytes to compare with the egg. At some point, I was way into debugging this and realised that showing a new way to do egg hunting, while it’d be cool, wasn’t exactly the point of this post, so I took a step back…</p><h2 id=egg-hunter-final-attemptcode--34-bytes>Egg hunter, final attempt/code – 34 bytes</h2><p>I decided to use the access syscall, shown by <a href=http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf target=_blank rel="nofollow noopener noreferrer"><span>Skape
</span></a>, because it’s the most robust, as is pointed out in Skape’s paper.</p><p>I also decided to use a 4 byte egg: 0xbeefbeef. The actual size of it mostly depends on you wishing to reduce the odds of finding this sequence along the memory. The bigger the egg, the lesser the chance for it to already be there in the VAS. So I figured, if four bytes was good enough for uniqueness in 32-bit systems, it’s good enough here too.</p><p>But, because I’m not duplicating its size, there’s the (very high) risk of the hunter actually detecting itself, because the egg is present in it’s own code. That’s why I set the EAX (lowest 32 bits of RAX) register with a different value, and make it right with the increment, right next (Figure 8 – lines 19, 20).</p><p><img src=images/fig83.png alt="Figure 8 – egg hunter (access)"></p><p>I won’t be explaining the details of each instruction, as I already did <a href=https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/ target=_blank rel="nofollow noopener noreferrer"><span>here
</span></a>and <a href=https://0x4ndr3.github.io/posts/x86_64-reverse-tcp-bind-shell-with-basic-authentication-on-linux-systems/ target=_blank rel="nofollow noopener noreferrer"><span>here
</span></a>.</p><p>At first (line 4), I zero out RSI which is the second parameter to the access syscall (F_OK=0). That same zero will be put in RDI which will contain the memory address to check if we have permissions to read from. Note that the actual first addressable memory position is not 0x00. But it’s small and close enough for us to ignore the latency in reaching it because, otherwise, we’d have to add some bytes to the code to add that logic.</p><p>The next_page label contains the code to increment the address to the next multiple of 4096, which is the next page in memory.</p><p>Then, in the next_4_bytes label, we basically go through calling access syscall, validating accessibility to the memory address in RDI, and if accessible, fetch the 4 bytes in it and compare it with our egg.</p><p>After compiling it:</p><blockquote><p># nasm -felf64 egghunter.nasm -o egghunter.o && ld egghunter.o -o egghunter</p></blockquote><p>extracting the hex code:</p><blockquote><p># for i in <code>objdump -d egghunter | tr ‘\t’ ‘ ‘ | tr ‘ ‘ ‘\n’ | egrep ‘^[0-9a-f]{2}$’ </code>; do echo -n “\x$i” ; done<br>\x48\x31\xf6\x56\x5f\x66\x81\xcf\xff\x0f\x48\xff\xc7\x6a\x15\x58\x0f\x05\x3c\xf2\x74\xef\xb8\xbd\xef\xbe\xef\xfe\xc0\xaf\x75\xed\xff\xe7</p></blockquote><p>adding it to the shellcode.c “test environment” (with a simple execve payload):</p><blockquote><p>#include &lt;stdio.h><br>#include &lt;string.h></p><p>#define EGG “\xBE\xEF\xBE\xEF”</p><p>unsigned char hunter[] = \<br>“\x48\x31\xf6\x56\x5f\x66\x81\xcf\xff\x0f\x48\xff\xc7\x6a\x15\x58\x0f\x05\x3c\xf2\x74\xef\xb8\xbd\xef\xbe\xef\xfe\xc0\xaf\x75\xed\xff\xe7”;</p><p>unsigned char payload[] = \<br>EGG<br>“\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x54\x5a\x57\x54\x5e\x0f\x05”;</p><p>int main(void) {<br>printf(“Egg hunter’s size (bytes): %lu\n”, strlen(hunter));<br>printf(“Payload’s size (bytes): %lu\n”, strlen(payload));<br>int (*ret)() = (int(*)())hunter;<br>ret();<br>}</p></blockquote><p>and compiling it:</p><blockquote><p># gcc -fno-stack-protector -z execstack shellcode.c -o shellcode</p></blockquote><p>It runs successfully:</p><p><img src=images/fig94.png alt="Figure 9 – egg hunter finding payload and executing it"></p><p>Notice how weird it is that the actual payload is smaller than the egg hunter. Well, that’s just this example because I’m using execve as a payload. But this particular payload, while being great for testing, it wouldn’t do much for me if I’m attacking a remote system. So, in a real scenario, we’d be using something like a <a href=https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/ target=_blank rel="nofollow noopener noreferrer"><span>bind shell
</span></a>or a <a href=https://0x4ndr3.github.io/posts/x86_64-reverse-tcp-bind-shell-with-basic-authentication-on-linux-systems/ target=_blank rel="nofollow noopener noreferrer"><span>reverse tcp shell
</span></a>.</p><p>Now this all looks good, right? Well it’s not. <strong>In order for this screenshot to be possible, I had to manipulate the application in the background</strong>:</p><p><img src="images/fig1012.png?w=616" alt="Figure 10 – manipulating the search position to get to the payload faster"></p><p>I’m basically attaching GDB to the running process (<em>attach 7660</em>), checking on the position of the first code section (the second and third are .data and .bss sections) with the <em>info proc mappings</em> command, setting the RDI register with that value <em>(set $RDI = …),</em> and telling the hunter to keep hunting with the <em>continue</em> (c) command*.*</p><p><strong>Why would I do that?</strong> You’d reasonably ask.</p><p>Because it takes sooooooo long to run through the user space in VAS in 64-bit architecture, even with all the cuts we’ve made (I left my Intel Core i7 laptop running throughout the night and nothing). This method would easily run through a 32-bit VAS, but definitely not a great option for 64-bit.</p><p>And because of memory randomisation (ASLR protection), the first section of the code doesn’t have a predictable position to start.</p><p><img src=images/fig114.png alt="Figure 11 – Value 2 indicating ASLR full randomisation"></p><p>I ran the shellcode application a few times, and these are some of the first code section addresses it had (proving the point of figure 11):</p><p><img src=images/fig113.png alt="Figure 12 – memory randomising the code/text section"></p><p>And this is why we see pretty much all x64 egg hunters, beginning their search at memory address on RDX. Because, in the typical test code for shellcodes (shellcode.c), RDX is the register with the memory position to the egg hunter’s code in memory. Starting from there saves the hunter hours (days/weeks?) of searching time:</p><p><img src=images/fig124.png alt="Figure 13 – Line 17 with the call to the egg hunter’s code"></p><p><img src=images/fig133.png alt="Figure 14 – assembly code with the call in figure 13’s line 17"></p><p>The advantage of using RDX as a starting point, is that, not only it’s WAY faster (pretty much instantaneous actually), it also gives you the ability to make the egg hunter’s code much smaller. This is because in this part of memory you’re sure to have read permissions, which voids the importance of the access syscall to prevent SIGSEGV interrupts.</p><p>And that’s why some of the codes out there are much smaller than the one showed here. Because they make assumptions that will sacrifice robustness and the ability to search everywhere, to favour speed (in only the very specific case of the typical C code used for testing shellcodes) and favour code shortening. Why would that sacrifice robustness? Because we have no idea of the meaning of the RDX’s value in the beginning of your hunter’s execution when actually executed in “real” applications, and the (very high) odds are that at some point it’ll run into unallocated memory positions, or pages you don’t have permissions to read from.</p><p>Bottom line: you’ll have to count on some persistence and a lot of luck for this to work in a real x64 system scenario.</p><p>You can find <a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments target=_blank rel="nofollow noopener noreferrer">
<span>all the files on my gitlab account
</span></a>.</p><p>Thanks to <a href=https://twitter.com/securitytube target=_blank rel="nofollow noopener noreferrer">
<span>Vivek Ramachandran
</span></a> and the <a href=http://www.pentesteracademy.com/topics target=_blank rel="nofollow noopener noreferrer">
<span>Pentester Academy
</span></a> team, as I have enjoyed every second of this course since I’ve learned so many interesting things. Appreciate your work!</p><hr><p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:</p><ul><li>Current URL: <a href=https://my.ine.com/CyberSecurity/courses/42f93b0f/x86_64-assembly-language-and-shellcoding-on-linux target=_blank rel="nofollow noopener noreferrer"><span>https://my.ine.com/CyberSecurity/courses/42f93b0f/x86_64-assembly-language-and-shellcoding-on-linux</span></a></li><li>Original URL (does not work anymore): <a href=http://www.securitytube-training.com/online-courses/x8664-assembly-and-shellcoding-on-linux/index.html target=_blank rel="nofollow noopener noreferrer"><span>http://www.securitytube-training.com/online-courses/x8664-assembly-and-shellcoding-on-linux/index.html</span></a></li></ul><p><strong>Student ID: PA-2109</strong></p></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div></main><footer class=footer><span>&copy; 2017 Andre Lima</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/gokarna-theme/gokarna-hugo>Gokarna</a></span></footer></body></html>