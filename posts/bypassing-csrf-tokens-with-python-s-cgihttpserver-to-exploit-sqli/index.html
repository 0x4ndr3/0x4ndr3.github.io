<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D;--font-size:1.1rem}</style><title>Bypassing CSRF tokens with Python’s CGIHTTPServer to exploit SQLi</title><meta name=description content="There are ways to configure Burpusing macros to bypass CSRF tokens on HTML forms, so we can use Burp Active Scans, Burp Intruder, Burp Repeater, and …"><meta name=keywords content='blog,gokarna,hugo'><meta property="og:url" content="https://0x4ndr3.github.io/posts/bypassing-csrf-tokens-with-python-s-cgihttpserver-to-exploit-sqli/"><meta property="og:type" content="website"><meta property="og:title" content="Bypassing CSRF tokens with Python’s CGIHTTPServer to exploit SQLi"><meta property="og:description" content="There are ways to configure Burpusing macros to bypass CSRF tokens on HTML forms, so we can use Burp Active Scans, Burp Intruder, Burp Repeater, and …"><meta property="og:image" content="https://0x4ndr3.github.io/main.png"><meta property="og:image:secure_url" content="https://0x4ndr3.github.io/main.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Bypassing CSRF tokens with Python’s CGIHTTPServer to exploit SQLi"><meta name=twitter:description content="There are ways to configure Burpusing macros to bypass CSRF tokens on HTML forms, so we can use Burp Active Scans, Burp Intruder, Burp Repeater, and …"><meta property="twitter:domain" content="https://0x4ndr3.github.io/posts/bypassing-csrf-tokens-with-python-s-cgihttpserver-to-exploit-sqli/"><meta property="twitter:url" content="https://0x4ndr3.github.io/posts/bypassing-csrf-tokens-with-python-s-cgihttpserver-to-exploit-sqli/"><meta name=twitter:image content="https://0x4ndr3.github.io/main.png"><link rel=canonical href=https://0x4ndr3.github.io/posts/bypassing-csrf-tokens-with-python-s-cgihttpserver-to-exploit-sqli/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.fdbfba1e074acb7e4abbf4c94eb19abb7702489c9689a27ee5e24a2bd481e4b7.js integrity="sha256-/b+6HgdKy35Ku/TJTrGau3cCSJyWiaJ+5eJKK9SB5Lc="></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://0x4ndr3.github.io/><img src=https://0x4ndr3.github.io/main.png alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://0x4ndr3.github.io/>0x4ndr3</a></div><div class=nav-links><div class=nav-link><a href=https://0x4ndr3.github.io/posts/ aria-label><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></div><div class=nav-link><a href=https://github.com/0x4ndr3 aria-label=github target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://0x4ndr3.github.io/posts/><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></li><li class=nav-item><a href=https://github.com/0x4ndr3 target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>Bypassing CSRF tokens with Python’s CGIHTTPServer to exploit SQLi</h1><small role=doc-subtitle></small><p class=post-date>October 9, 2017</p><ul class=post-tags></ul></div><div class=post-content><p>There are ways to configure <a href=https://portswigger.net/burp target=_blank rel="nofollow noopener noreferrer"><span>Burp
</span></a>using macros to bypass CSRF tokens on HTML forms, so we can use Burp Active Scans, Burp Intruder, Burp Repeater, and (cautiously) even Burp Proxy. There’s also Grep-Extract and pitchfork attack type specifically for Intruder. And, you might even develop your Burp Extension to do it. <a href=https://github.com/sqlmapproject/sqlmap target=_blank rel="nofollow noopener noreferrer"><span>Sqlmap
</span></a>has a <em>-–csrf-token</em> and a <em>&ndash;csrf-url</em> for the same purpose, or you can just configure Burp as previously stated, and run sqlmap through Burp using <em>–-proxy</em>.</p><p>Now, here’s another way, using CGIHTTPServer from python.</p><h2 id=the-lab>The lab</h2><p>The lab is a simple PHP/mysql environment, in which you login to access a restricted area. I uploaded the <a href=https://gitlab.com/0x4ndr3/blog_post_csrf_bypass_with_cgihttpserver.git target=_blank rel="nofollow noopener noreferrer"><span>PHP code here
</span></a>, in case you want to try it out, and change/adjust it for other scenarios. Just bear with me, because I’m not a PHP specialist, but I do prefer to develop the environment I’m testing (within reason). It always helps you understand better what you’re testing and what to look for in real world scenarios.</p><p>The CSRF token is a SHA256 hash of a randomly generated number, and it’s different for each HTTP request.</p><p><img src=images/fig0-e1507524527330.png alt=fig0></p><h2 id=the-problem>The problem</h2><p>So, without any special configurations, Burp won’t detect the issue.</p><p><img src=images/fig1.png alt=fig1></p><p>And neither will sqlmap:</p><p><img src=images/fig2.png alt=fig2></p><p>I used the <em>–technique</em>, <em>–dbms</em>, and <em>-p</em> flags to speed up the scan. And since this is a simple boolean-based SQLi, <em>–level 1</em> (the default) is more than enough. But the <em>–risk</em> must indeed be set to 3. This is because only on that higher risk number, OR boolean-based SQL injections are tested. OR boolean-based SQL injections are dangerous because they can make any condition become true. If you think about cases where you inject into a WHERE clause of an UPDATE or DELETE statements, you could accidentally update, let’s say, the passwords for all users on the database, or dump that user’s credentials table… exactly the kind of thing you avoid at all costs when performing pentests to your clients.</p><p>OR boolean-based SQLi detected with sqlmap <em>–csrf-token=”mytoken”</em>:</p><p><img src=images/fig3-e1507525426670.png alt=fig3></p><p>But because this is a login validation form, it’s obviously a SELECT statement, which means there’s no harm in the highest risk 3.</p><p>Of course, if you have valid credentials (which you might not have in a real pentest), this is also vulnerable to AND boolean-based SQLi. But even if I do have valid credentials, I’d rather first test it with another (valid) username to find an OR SQLi, so I don’t accidently lock the account (if it does lock at all).</p><p>AND boolean-based SQLi also detected with <em>–csrf-token=”mytoken”</em>:</p><p><img src=images/fig4-e1507525470380.png alt=fig4></p><h2 id=cgihttpserver-for-the-rescue>CGIHTTPServer for the rescue</h2><p>Creating the CGI script:</p><p><img src=images/fig5.png alt=fig5></p><p>This should be created inside folder_whatever/cgi-bin/, which we’ll call <em>mask.py</em> , and make sure the <em>.py</em> is executable. After the file is created, run “<em>python -m CGIHTTPServer</em>” from within “<em>folder_whatever</em>“. It will, by default, listen on the 8000/tcp port.</p><p><img src=images/fig6.png alt=fig6></p><p>You can test it, with the correct password:</p><p><img src=images/fig7.png alt=fig7></p><p>And with the wrong one:</p><p><img src=images/fig8.png alt=fig8></p><p>So now, it becomes pretty easy to detect, without any special configuration, to both Burp and sqlmap.</p><p><img src=images/fig10.png alt=fig10></p><p><img src=images/fig9.png alt=fig9></p><p>It’s as if we added a “mask” to simplify the extra complexity of the real request – the CSRF token – that we’d have to submit, and now we don’t.</p><h3 id=references>References</h3><ul><li><a href=https://github.com/sqlmapproject/sqlmap/blob/master/README.md target=_blank rel="nofollow noopener noreferrer"><span>Sqlmap</span></a></li><li><a href=http://mechanize.readthedocs.io/en/latest/browser_api.html#the-response target=_blank rel="nofollow noopener noreferrer"><span>Some other ways to respond using Mechanizer, so the scanners can detect a difference in response</span></a></li><li><a href=https://portswigger.net/burp/help/options_sessions_macroeditor.html target=_blank rel="nofollow noopener noreferrer"><span>Burp Macros</span></a></li></ul></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div></main><footer class=footer><span>&copy; 2017 Andre Lima</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/gokarna-theme/gokarna-hugo>Gokarna</a></span></footer></body></html>