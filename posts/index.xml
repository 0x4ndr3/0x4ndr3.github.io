<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 0x4ndr3</title><link>https://0x4ndr3.github.io/posts/</link><description>Recent content in Posts on 0x4ndr3</description><generator>Hugo</generator><language>en-uk</language><lastBuildDate>Mon, 23 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://0x4ndr3.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Starting dynamic analysis on a Windows x64 rootkit</title><link>https://0x4ndr3.github.io/posts/starting-dynamic-analysis-on-a-windows-x64-rootkit/</link><pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate><guid>https://0x4ndr3.github.io/posts/starting-dynamic-analysis-on-a-windows-x64-rootkit/</guid><description>&lt;p&gt;&lt;img src="images/17.png" alt="17"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Starting dynamic analysis on a Windows x64 rootkit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this blog post, we will be operating under the assumption that you have retrieved a Windows kernel rootkit sample and want to breakpoint into the DriverEntry function, which is the equivalent of the *main *function in a normal executable file, but for the rootkit/driver. This might seem straight forward, and it is when you have the source code (technique #1) or the symbols for the payload (technique #2), but it’s not as straight-forward when you don’t have either (technique #3). The latter is typically the case when you need to analyze a malicious sample.&lt;/p&gt;</description></item><item><title>Assembly wrapping: a technique for anti-disassembly</title><link>https://0x4ndr3.github.io/posts/assembly-wrapping-a-new-technique-for-anti-disassembly/</link><pubDate>Mon, 08 Jun 2020 00:00:00 +0000</pubDate><guid>https://0x4ndr3.github.io/posts/assembly-wrapping-a-new-technique-for-anti-disassembly/</guid><description>&lt;p&gt;&lt;strong&gt;Assembly “wrapping”: a technique for anti-disassembly&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jun 8, 2020&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; user &lt;a
 
 href = "https://www.reddit.com/user/RelativeTrifle"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 RelativeTrifle
 &lt;/span&gt;
&lt;/a&gt; at the &lt;a
 
 href = "https://www.reddit.com/r/ReverseEngineering/"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 ReverseEngineering
 &lt;/span&gt;
&lt;/a&gt; subreddit pointed out to me that this is not a new concept, as Johannes Kinder had already written about it in 2010 while calling it “&lt;a
 
 href = "http://infoscience.epfl.ch/record/167546/files/thesis.pdf"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 overlapping instructions
 &lt;/span&gt;
&lt;/a&gt;”. This paper was mentioned at &lt;a
 
 href = "https://reverseengineering.stackexchange.com/questions/1531/what-is-overlapping-instructions-obfuscation"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 StackExchange
 &lt;/span&gt;
&lt;/a&gt; in 2013. While I did research terms and expressions in order to figure out if this technique had been mentioned before, it is very hard to guess what it could be called by someone else. Therefore, I apologize to Johannes Kinder for having had the “new” in the title, as it isn’t. However, I will still keep this article as it shows some more practical examples/code that helps in its understanding and execution, and is based on x64, instead of x86, which gives the programmer more “room to play”. I just wanted to credit Johannes Kinder for the original idea.&lt;/p&gt;</description></item><item><title>JSgen.py – bind and reverse shell JS code generator for SSJI in Node.js with filter bypass encodings</title><link>https://0x4ndr3.github.io/posts/jsgen-py-bind-and-reverse-shell-js-code-generator-for-ssji-in-node-js-with-filter-bypass-encodings/</link><pubDate>Thu, 28 Jun 2018 07:21:30 +0200</pubDate><guid>https://0x4ndr3.github.io/posts/jsgen-py-bind-and-reverse-shell-js-code-generator-for-ssji-in-node-js-with-filter-bypass-encodings/</guid><description>&lt;p&gt;I wrote a Python script (&lt;a
 
 href = "https://gitlab.com/0x4ndr3/blog/blob/master/JSgen/JSgen.py"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 JSgen.py
 &lt;/span&gt;
&lt;/a&gt;) to generate javascript code to be injected in case you find a Server Side Javascript Injection (SSJI). It supports both bind and reverse shells, and also two well known encodings – hex and base64 – as well as a third one – caesar’s cipher – to help in bypassing weak filters.&lt;/p&gt;</description></item><item><title>Twofish Crypter with DNS (CName) password retrieval, x64 shellcode decryption, and execution</title><link>https://0x4ndr3.github.io/posts/twofish-crypter-with-dns-cname-password-retrieval-x64-shellcode-decryption-and-execution/</link><pubDate>Fri, 02 Feb 2018 09:14:31 +0100</pubDate><guid>https://0x4ndr3.github.io/posts/twofish-crypter-with-dns-cname-password-retrieval-x64-shellcode-decryption-and-execution/</guid><description>&lt;p&gt;&lt;strong&gt;[Update: 7 April 2018]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I altered the Decrypter.c, not to get the raw password from the CNAME record from password.andrelima.info , but instead to get an hex encoded password from the same record in passwordhex.andrelima.info&lt;/p&gt;
&lt;p&gt;This feature allows the Crypter to encrypt the shellcode with &lt;strong&gt;passwords containing special characters&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;So, bear in mind some screenshots below might be outdated, but not the following:&lt;/p&gt;
&lt;p&gt;&lt;img src="images/screen-shot-2018-04-07-at-8-47-24-pm.png" alt="Screen Shot 2018-04-07 at 8.47.24 pm"&gt;&lt;/p&gt;
&lt;p&gt;Crypter now presenting the password used secret_%”123 in hex to insert in the CNAME record&lt;/p&gt;</description></item><item><title>Polymorphic and smaller versions of three shell-storm’s x64 shellcodes, including the smallest execve /bin/sh</title><link>https://0x4ndr3.github.io/posts/polymorphic-and-smaller-versions-of-three-shell-storm-s-x64-shellcodes-including-the-smallest-execve-bin-sh/</link><pubDate>Fri, 12 Jan 2018 15:12:53 +0100</pubDate><guid>https://0x4ndr3.github.io/posts/polymorphic-and-smaller-versions-of-three-shell-storm-s-x64-shellcodes-including-the-smallest-execve-bin-sh/</guid><description>&lt;p&gt;&lt;strong&gt;[Update 13 Jan 2018]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ExploitDB has published the &lt;a
 
 href = "https://www.exploit-db.com/shellcodes?author=9244"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 3 shellcodes
 &lt;/span&gt;
&lt;/a&gt; written in this blog post.&lt;/p&gt;
&lt;p&gt;Linux/x86-64 – &lt;a
 
 href = "https://www.exploit-db.com/exploits/43550/"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 Execute /bin/sh
 &lt;/span&gt;
&lt;/a&gt; Shellcode (24 bytes)&lt;br&gt;
Linux/x86-64 – &lt;a
 
 href = "https://www.exploit-db.com/exploits/43552/"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 Add Map (127.1.1.1 google.lk) In /etc/hosts
 &lt;/span&gt;
&lt;/a&gt; Shellcode (96 bytes)&lt;br&gt;
Linux/x86-64 – &lt;a
 
 href = "https://www.exploit-db.com/exploits/43553/"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 execve(“/sbin/iptables”, [“/sbin/iptables”, “-F”], NULL)
 &lt;/span&gt;
&lt;/a&gt; Shellcode (43 bytes)&lt;/p&gt;</description></item><item><title>Custom x64 encoder with a basic polymorphic engine implementation</title><link>https://0x4ndr3.github.io/posts/custom-x64-encoder-with-a-basic-polymorphic-engine-implementation/</link><pubDate>Mon, 18 Dec 2017 00:09:51 +0100</pubDate><guid>https://0x4ndr3.github.io/posts/custom-x64-encoder-with-a-basic-polymorphic-engine-implementation/</guid><description>&lt;p&gt;I’ll develop a python encoder that will XOR the payload, byte by byte, with a randomly generated byte value, and also generate a polymorphic stub in x64 to decode that payload, by brute-forcing all 256 possibilities. Even though bypassing anti-virus systems is not the only purpose of encoders, it certainly is the most exciting one, and hence the detailed focus on this one subject throughout this post.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Update [20 Dec 2017]&lt;/strong&gt;:&lt;/p&gt;</description></item><item><title>x64 Egg hunting in Linux systems</title><link>https://0x4ndr3.github.io/posts/x64-egg-hunting-in-linux-systems/</link><pubDate>Fri, 24 Nov 2017 00:42:48 +0100</pubDate><guid>https://0x4ndr3.github.io/posts/x64-egg-hunting-in-linux-systems/</guid><description>&lt;p&gt;There isn’t much when it comes to egg hunters, and even less when it comes to x64 ones. And the ones out there on &lt;a
 
 href = "https://www.exploit-db.com/shellcode"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 exploit-db
 &lt;/span&gt;
&lt;/a&gt; and &lt;a
 
 href = "http://shell-storm.org/shellcode/"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 shell-storm
 &lt;/span&gt;
&lt;/a&gt; do leave a lot to be explained, and some… let’s just say I can’t imagine the authors even bothered to test them, let alone read Skape’s paper on &lt;a
 
 href = "http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 Safely Searching Process Virtual Address Space
 &lt;/span&gt;
&lt;/a&gt;. Fortunately, Skape’s paper exists and, together with a &lt;a
 
 href = "https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 lot of reading
 &lt;/span&gt;
&lt;/a&gt; … and &lt;a
 
 href = "https://static.lwn.net/images/pdf/LDD3/ch15.pdf"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 some more reading
 &lt;/span&gt;
&lt;/a&gt;, on memory models, virtual address space, etc, I hope to be able to explain this in the simplest of ways.&lt;/p&gt;</description></item><item><title>x86_64 reverse TCP bind shell with basic authentication on Linux systems</title><link>https://0x4ndr3.github.io/posts/x86_64-reverse-tcp-bind-shell-with-basic-authentication-on-linux-systems/</link><pubDate>Mon, 13 Nov 2017 11:40:35 +0100</pubDate><guid>https://0x4ndr3.github.io/posts/x86_64-reverse-tcp-bind-shell-with-basic-authentication-on-linux-systems/</guid><description>&lt;p&gt;The objective here is to create a reverse TCP bind shell using assembly x64, which will authenticate the attacker through a password, and have no Null bytes (0x00) in it.&lt;/p&gt;
&lt;p&gt;So, where to start? Much like the &lt;a
 
 href = "https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 previous post
 &lt;/span&gt;
&lt;/a&gt;, by basing our code on the C equivalent source code. &lt;a
 
 href = "https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_02/original%20basic%20reverse%20shell/Reverse-Shell.c"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 Here is
 &lt;/span&gt;
&lt;/a&gt; what a reverse tcp shell looks like in C:&lt;/p&gt;</description></item><item><title>x86_64 TCP bind shellcode with basic authentication on Linux systems</title><link>https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/</link><pubDate>Wed, 01 Nov 2017 08:44:30 +0100</pubDate><guid>https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/</guid><description>&lt;p&gt;The objective here is to create a tcp_bind_shell using Assembly x64, which will ask for a passcode, and have no null bytes in it.&lt;/p&gt;
&lt;p&gt;So, where to start? By basing our code on the C equivalent source code. &lt;a
 
 href = "https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_01/original%20basic%20bind%20shell/Bind-Shell.c"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 Here is
 &lt;/span&gt;
&lt;/a&gt; what a tcp_bind_shell looks like in C:&lt;/p&gt;
&lt;p&gt;&lt;a
 
 href = "https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_01/original%20basic%20bind%20shell/Bind-Shell.c"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 &lt;img src="images/fig1-e1509498273204.png" alt="Figure 1 – Simple tcp_bind_shell in C"&gt;
 &lt;/span&gt;
&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Bypassing CSRF tokens with Python’s CGIHTTPServer to exploit SQLi</title><link>https://0x4ndr3.github.io/posts/bypassing-csrf-tokens-with-python-s-cgihttpserver-to-exploit-sqli/</link><pubDate>Mon, 09 Oct 2017 08:05:19 +0200</pubDate><guid>https://0x4ndr3.github.io/posts/bypassing-csrf-tokens-with-python-s-cgihttpserver-to-exploit-sqli/</guid><description>&lt;p&gt;There are ways to configure &lt;a
 
 href = "https://portswigger.net/burp"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 Burp
 &lt;/span&gt;
&lt;/a&gt; using macros to bypass CSRF tokens on HTML forms, so we can use Burp Active Scans, Burp Intruder, Burp Repeater, and (cautiously) even Burp Proxy. There’s also Grep-Extract and pitchfork attack type specifically for Intruder. And, you might even develop your Burp Extension to do it. &lt;a
 
 href = "https://github.com/sqlmapproject/sqlmap"
 
 
 
 target = "_blank"
 rel = "nofollow noopener noreferrer"
 &gt;
 &lt;span&gt;
 Sqlmap
 &lt;/span&gt;
&lt;/a&gt; has a &lt;em&gt;-–csrf-token&lt;/em&gt; and a &lt;em&gt;&amp;ndash;csrf-url&lt;/em&gt; for the same purpose, or you can just configure Burp as previously stated, and run sqlmap through Burp using &lt;em&gt;–-proxy&lt;/em&gt;.&lt;/p&gt;</description></item></channel></rss>