<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D;--font-size:1.1rem}</style><title>Custom x64 encoder with a basic polymorphic engine implementation</title><meta name=description content="I’ll develop a python encoder that will XOR the payload, byte by byte, with a randomly generated byte value, and also generate a polymorphic stub in x64 to …"><meta name=keywords content='blog,gokarna,hugo'><meta property="og:url" content="https://0x4ndr3.github.io/posts/custom-x64-encoder-with-a-basic-polymorphic-engine-implementation/"><meta property="og:type" content="website"><meta property="og:title" content="Custom x64 encoder with a basic polymorphic engine implementation"><meta property="og:description" content="I’ll develop a python encoder that will XOR the payload, byte by byte, with a randomly generated byte value, and also generate a polymorphic stub in x64 to …"><meta property="og:image" content="https://0x4ndr3.github.io/main.png"><meta property="og:image:secure_url" content="https://0x4ndr3.github.io/main.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Custom x64 encoder with a basic polymorphic engine implementation"><meta name=twitter:description content="I’ll develop a python encoder that will XOR the payload, byte by byte, with a randomly generated byte value, and also generate a polymorphic stub in x64 to …"><meta property="twitter:domain" content="https://0x4ndr3.github.io/posts/custom-x64-encoder-with-a-basic-polymorphic-engine-implementation/"><meta property="twitter:url" content="https://0x4ndr3.github.io/posts/custom-x64-encoder-with-a-basic-polymorphic-engine-implementation/"><meta name=twitter:image content="https://0x4ndr3.github.io/main.png"><link rel=canonical href=https://0x4ndr3.github.io/posts/custom-x64-encoder-with-a-basic-polymorphic-engine-implementation/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.fdbfba1e074acb7e4abbf4c94eb19abb7702489c9689a27ee5e24a2bd481e4b7.js integrity="sha256-/b+6HgdKy35Ku/TJTrGau3cCSJyWiaJ+5eJKK9SB5Lc="></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://0x4ndr3.github.io/><img src=https://0x4ndr3.github.io/main.png alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://0x4ndr3.github.io/>0x4ndr3</a></div><div class=nav-links><div class=nav-link><a href=https://0x4ndr3.github.io/posts/ aria-label><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></div><div class=nav-link><a href=https://github.com/0x4ndr3 aria-label=github target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://0x4ndr3.github.io/posts/><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></li><li class=nav-item><a href=https://github.com/0x4ndr3 target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>Custom x64 encoder with a basic polymorphic engine implementation</h1><small role=doc-subtitle></small><p class=post-date>December 18, 2017</p><ul class=post-tags></ul></div><div class=post-content><p>I’ll develop a python encoder that will XOR the payload, byte by byte, with a randomly generated byte value, and also generate a polymorphic stub in x64 to decode that payload, by brute-forcing all 256 possibilities. Even though bypassing anti-virus systems is not the only purpose of encoders, it certainly is the most exciting one, and hence the detailed focus on this one subject throughout this post.</p><hr><p><strong>Update [20 Dec 2017]</strong>:</p><p>I improved the <a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_04/encoder.py target=_blank rel="nofollow noopener noreferrer"><span>python’s code
</span></a>to not only generate the random byte (to xor the original payload byte by byte), but to also validate if the xor’ed payload will have any bad characters (in this case, just the null byte 0x00). Made it so you can simply add any others to the “bad_chars” list.</p><p>So don’t expect the screenshots to match the code exactly, because of this new logic I added.</p><p>I added de function valid(byte), and also a loop until a valid random byte (R) is generated:</p><p><a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_04/encoder.py target=_blank rel="nofollow noopener noreferrer"><span><img src=images/fig11.png alt=fig11.png></span></a></p><p>And sometimes, after executing the encoder.py , you’ll realise it had to re-execute:</p><p><img src=images/fig12.png alt=fig12.png></p><p>Thanks to <a href=https://malwrecon.blogspot.com.au/ target=_blank rel="nofollow noopener noreferrer"><span>MalwRecon
</span></a>for bringing that to my attention. Appreciate the feedback!</p><hr><p>So what are encoders? Encoders are shellcode made of two distinct parts:</p><p><img src=images/fig1.png alt="Figure 1 – Decoder structure"></p><p>The first is called the stub, and it’s the code responsible to decode the second part, the payload. An example is a XOR encoder, in which you xor the payload byte by byte with the value 0xAA, and you then write the stub which will just run through the payload, byte by byte, xor it with 0xAA, and then execute the decoded payload.</p><p>For the sake of simplicity, the encoding of the payload is usually done in a high level programming language, such as Python, while the decoder, obviously being done in x64 assembly, because that’ll be the actual shellcode.</p><h3 id=the-stubs-algorithm--brute-force>The stub’s algorithm – brute force</h3><p>I decided I wanted to create a variation of the xor encoder, but one which will xor the payload with a randomly generated byte. The problem with this approach is that you won’t have a generic decoder that works, because you’ll have to insert the randomly generated byte to xor the payload with, in it. I solved this by deciding to use a generic decoder, which stub will brute force the payload until it finds the right value. This brings us to another issue: How will the stub know when it found the right byte? A generic approach is to simply prepend a signature to the shellcode so, if after xor’ing the first byte from the payload, with current iteration’s byte (iteration from the brute force), it finds the signature byte, then that iteration’s byte value is the “key”. In this case, I decided to prepend the byte value 0x90, which is convenient, because I won’t have to adjust the decoded payload pointer to position X+1 due to the fact that 0x90 is a NOP instruction, which is harmless to execute.</p><p>Do note the double quotes around the word key, I used in the previous paragraph, as I’m trying to avoid any misconception between this encoding and an actual encryption algorithm. Knowing that my signature is 0x90, anyone would simply have to xor this value with the first encoded payload’s byte, and the “key” would be revealed. This encoder’s purpose was never meant to hide the payload from an attacker, but rather (for the purpose of this post) to misguide any signature based anti-virus engine that tries to detect it.</p><p>But let’s first take a look at a first draft of this encoder (without polymorphism):</p><p><img src=images/fig21.png alt="Figure 2 – draft #1 of decoder (without polymorphism)"></p><p>The first lines of code (lines [6-9]) is using one of the techniques in shellcoding to get addresses in memory, without having to use absolute jumps. This is important in shellcoding because you have no idea where the shellcode will be placed in memory, and absolute jumps will certainly go wrong. This technique is called “jmp-call-pop” (JCP) and is used to place the memory address of data (in this case the payload) into a register (RDI). After that, I backup the value in register RBX as well, because when I find out the random byte used to xor the payload, I’ll be going through it by incrementing RDI, and in the end I need to JMP to the start of it, which will be in RBX (line 33).</p><p>The code after that, is pretty straight forward. It performs the brute force (lines [13-21]) while trying to match the result of the xor operation with the signature 0x90, and after finding that value, it goes through the payload xor’ing all bytes with that value. In the end it simply JMP’s to the decoded payload and start executing the code.</p><h3 id=signature-based-malware-detection>Signature-based malware detection</h3><p>Because it is not only faster, but a less resource consuming technique, signature-based detection is the method used by pretty much all anti-virus engines. This is, generically speaking, searching for a binary string inside a file.</p><p>Now regarding the decoder’s draft #1, while we will dodge the detection of the payload itself with its xor’ing, <strong>we still have a huge problem, which is the way anti-virus engines found to still detect encoders (or crypters for that matter): detecting not the payload, but the stub itself</strong>.</p><p>Let’s use the open source Anti Virus system <a href=https://github.com/Cisco-Talos/clamav target=_blank rel="nofollow noopener noreferrer"><span>ClamAV
</span></a>to show how this could be done.</p><p>After compiling <em>(nasm -f elf64 … && ld …)</em> the code from Figure 1, we end up with the following binary file (which is the binary string for the shellcode):</p><p><img src=images/fig3.png alt="Figure 3 – objdump of draft #1 binary"></p><p>Analysing the shellcode, we decide to generate a signature for our AV and put inside a database file called “sig.ndb”:</p><blockquote><p>mySig:0:*:eb255f575b8a174831ff48ffc788d04030f83c**??**75f46a1b594088f8535f</p></blockquote><p>The structure of the signatures inside this ClamAV database is:</p><ul><li>unique name/ID for the signature</li><li>type of file (0 – any type, 1- PE, 6 – ELF, 9 – MachO)</li><li>offset (* – any)</li><li>hex formatted signature</li></ul><p>If you want to read more about malware analysis techniques like this, I’d definitely recommend <a href="https://www.amazon.com/Malware-Analysts-Cookbook-DVD-Techniques/dp/0470613033/ref=pd_sim_14_2" target=_blank rel="nofollow noopener noreferrer">
<span>Malware Analyst’s Cookbook and DVD
</span></a>and <a href=https://www.amazon.com/Practical-Malware-Analysis-Hands-Dissecting/dp/1593272901 target=_blank rel="nofollow noopener noreferrer"><span>Practical Malware Analysis
</span></a>.</p><p>Now notice how there is a “??” in between the signature. It’s exactly where the 0x90 was supposed to be. This makes the signature more flexible, by still detecting decoders based on this one with signatures other than 0x90.</p><p>After testing the file with ClamAV, the detection is shown:</p><p><img src=images/fig4.png alt="Figure 4 – AV detection of static stub (“FOUND”)"></p><p>And that’s why <strong>we need polymorphism to also evade this stub detection</strong>.</p><h3 id=polymorphic-engine>Polymorphic engine</h3><p>Polymorphism, in this context, is nothing but altering the instructions (signature) of the code, while still doing the exact same thing.</p><p>At this point, the entire focus is in the encoder’s Python code, which will be (contrary to common encoders) generating the x64 ASM decoder code itself: decoder.nasm which makes sense, since this code will be different every time it’s generated.</p><p>Now to the code. The first part of it contains our payload (execve), which is appended to the signature byte 0x90, and you can also see the randomly generated byte (line 7) that will be xor’ed with every byte in the payload.</p><p><img src=images/fig5.png alt="Figure 5 – shellcode attached to the “signature” byte: 0x90"></p><p>After the python’s algorithm that will xor/encode the payload (check the entire code <a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_04/encoder.py target=_blank rel="nofollow noopener noreferrer"><span>here
</span></a>), you’ll find some prints (that help in the debugging process), and then:</p><p><img src=images/fig6.png alt="Figure 6 – decoder with polymorphic generation"></p><p>The core of the code generation here is the poly(…) function.</p><p><img src=images/fig7.png alt="Figure 7 – polymorphic algorithm implemented"></p><p>This is simply a function that will search for the given instruction inside a dictionary type container (line 29). The result of this search is a list of options to swap the original instruction with. The choosing of which item in the list to swap with, is done randomly (line 65). As you can see, I only provided 2 alternatives, one of them being the instruction itself, but this will be more than enough for evading the signature-based detection.</p><p>So let’s test it! After executing the encoder, compiling and extracting the shellcode:</p><blockquote><p># ./encoder.py</p><p># nasm -felf64 decoder.nasm -o decoder.o && ld decoder.o -o decoder</p></blockquote><p>I then executed the AV and…</p><p><img src=images/fig8.png alt="Figure 8 – Signature-based detection fail (“OK”)"></p><p>No more detection!</p><p>And, of course the code still runs fine inside shellcode.c :</p><blockquote><p># ./encoder.py</p><p># nasm -felf64 decoder.nasm -o decoder.o && ld decoder.o -o decoder</p><p># for i in <code>objdump -d decoder | tr ‘\t’ ‘ ‘ | tr ‘ ‘ ‘\n’ | egrep ‘^[0-9a-f]{2}$’ </code>; do echo -n “\x$i” ; done;echo<br>\xeb\x47\x48\x8b\x3c\x24\x48\x83\xc4\x08\x48\x89\xfb\x8a\x17\x48\x31\xff\x48\xff\xcf\x48\x83\xc7\x02\x41\x88\xd1\x44\x88\xc8\x41\x88\xf9\x44\x30\xc8\xb4\xff\x66\x83\xf8\x90\x75\xe5\x6a\x1b\x59\x40\x88\xf8\x53\x5f\x44\x8a\x0f\x41\x30\xc1\x44\x88\x0f\x48\xff\xcf\x48\x83\xc7\x02\xe2\xee\xff\xe3\xe8\xb4\xff\xff\xff\x8e\x74\x25\x46\x87\x4c\x56\xa5\x31\x31\x7c\x77\x70\x31\x6d\x76\x4d\x4a\x41\x4c\x4a\x40\x49\x4a\x44\x11\x1b</p><p># gcc -fno-stack-protector -z execstack shellcode.c -o shellcode</p></blockquote><p><img src=images/fig9.png alt="Figure 9 – executing shellcode.c compilation"></p><p>The interesting thing about Figure 9 is that, because of the polymorphic engine, it generates a different shellcode every time you execute encoder.py , so after running it, compiling the decoder.nasm and repeating the whole process to generate shellcode binary, it ran (again) as follows:</p><p><img src=images/fig10.png alt="Figure 10 – shellcode rebuild with a different size"></p><p>Notice the difference in the shellcode’s length. In figure 9 it had 105 bytes, and in Figure 10, it has 94 bytes. This will vary every time you repeat the process, due to the engine generating different code with different byte lengths.</p><p>Bear in mind that this is a basic polymorphic engine implementation. Not only it does not allow for many instructions to be altered (it pretty much only serves the code inside my stub), but the implementation itself could be more flexible (instead of entries for “mov rax,rbx” for instance, it would have a generic “mov r64,r64”). This is something I intend to look more into in the future (by reviewing my compiler’s study material) and make a better implementation that will support many more instructions.</p><p>You can find <a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments target=_blank rel="nofollow noopener noreferrer">
<span>all the files on my gitlab account
</span></a>.</p><p>Thanks to <a href=https://twitter.com/securitytube target=_blank rel="nofollow noopener noreferrer">
<span>Vivek Ramachandran
</span></a> and the <a href=http://www.pentesteracademy.com/topics target=_blank rel="nofollow noopener noreferrer">
<span>Pentester Academy
</span></a> team, as I have enjoyed every second of this course since I’ve learned so many interesting things, and all this inspired me to learn even more. Appreciate your work!</p><hr><p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:</p><ul><li>Current URL: <a href=https://my.ine.com/CyberSecurity/courses/42f93b0f/x86_64-assembly-language-and-shellcoding-on-linux target=_blank rel="nofollow noopener noreferrer"><span>https://my.ine.com/CyberSecurity/courses/42f93b0f/x86_64-assembly-language-and-shellcoding-on-linux</span></a></li><li>Original URL (does not work anymore): <a href=http://www.securitytube-training.com/online-courses/x8664-assembly-and-shellcoding-on-linux/index.html target=_blank rel="nofollow noopener noreferrer"><span>http://www.securitytube-training.com/online-courses/x8664-assembly-and-shellcoding-on-linux/index.html</span></a></li></ul><p><strong>Student ID: PA-2109</strong></p></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div></main><footer class=footer><span>&copy; 2017 Andre Lima</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/gokarna-theme/gokarna-hugo>Gokarna</a></span></footer></body></html>