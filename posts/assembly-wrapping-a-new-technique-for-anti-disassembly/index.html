<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D;--font-size:1.1rem}</style><title>Assembly wrapping: a technique for anti-disassembly</title><meta name=description content="Assembly “wrapping”: a technique for anti-disassembly
Jun 8, 2020
Update: user RelativeTrifleat the ReverseEngineeringsubreddit pointed out to me that this is …"><meta name=keywords content='blog,gokarna,hugo'><meta property="og:url" content="https://0x4ndr3.github.io/posts/assembly-wrapping-a-new-technique-for-anti-disassembly/"><meta property="og:type" content="website"><meta property="og:title" content="Assembly wrapping: a technique for anti-disassembly"><meta property="og:description" content="Assembly “wrapping”: a technique for anti-disassembly
Jun 8, 2020
Update: user RelativeTrifleat the ReverseEngineeringsubreddit pointed out to me that this is …"><meta property="og:image" content="https://0x4ndr3.github.io/posts/assembly-wrapping-a-new-technique-for-anti-disassembly/images/03.png"><meta property="og:image:secure_url" content="https://0x4ndr3.github.io/posts/assembly-wrapping-a-new-technique-for-anti-disassembly/images/03.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Assembly wrapping: a technique for anti-disassembly"><meta name=twitter:description content="Assembly “wrapping”: a technique for anti-disassembly
Jun 8, 2020
Update: user RelativeTrifleat the ReverseEngineeringsubreddit pointed out to me that this is …"><meta property="twitter:domain" content="https://0x4ndr3.github.io/posts/assembly-wrapping-a-new-technique-for-anti-disassembly/"><meta property="twitter:url" content="https://0x4ndr3.github.io/posts/assembly-wrapping-a-new-technique-for-anti-disassembly/"><meta name=twitter:image content="https://0x4ndr3.github.io/posts/assembly-wrapping-a-new-technique-for-anti-disassembly/images/03.png"><link rel=canonical href=https://0x4ndr3.github.io/posts/assembly-wrapping-a-new-technique-for-anti-disassembly/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.fdbfba1e074acb7e4abbf4c94eb19abb7702489c9689a27ee5e24a2bd481e4b7.js integrity="sha256-/b+6HgdKy35Ku/TJTrGau3cCSJyWiaJ+5eJKK9SB5Lc="></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://0x4ndr3.github.io/><img src=https://0x4ndr3.github.io/pic.png alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://0x4ndr3.github.io/>0x4ndr3</a></div><div class=nav-links><div class=nav-link><a href=https://0x4ndr3.github.io/posts/ aria-label><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></div><div class=nav-link><a href=https://github.com/0x4ndr3 aria-label=github target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://0x4ndr3.github.io/posts/><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></li><li class=nav-item><a href=https://github.com/0x4ndr3 target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>Assembly wrapping: a technique for anti-disassembly</h1><small role=doc-subtitle></small><p class=post-date>June 8, 2020</p><ul class=post-tags></ul></div><div class=post-content><p><strong>Assembly “wrapping”: a technique for anti-disassembly</strong></p><p>Jun 8, 2020</p><p><strong>Update:</strong> user <a href=https://www.reddit.com/user/RelativeTrifle target=_blank rel="nofollow noopener noreferrer">
<span>RelativeTrifle
</span></a> at the <a href=https://www.reddit.com/r/ReverseEngineering/ target=_blank rel="nofollow noopener noreferrer">
<span>ReverseEngineering
</span></a> subreddit pointed out to me that this is not a new concept, as Johannes Kinder had already written about it in 2010 while calling it “<a href=http://infoscience.epfl.ch/record/167546/files/thesis.pdf target=_blank rel="nofollow noopener noreferrer">
<span>overlapping instructions
</span></a>”. This paper was mentioned at <a href=https://reverseengineering.stackexchange.com/questions/1531/what-is-overlapping-instructions-obfuscation target=_blank rel="nofollow noopener noreferrer">
<span>StackExchange
</span></a> in 2013. While I did research terms and expressions in order to figure out if this technique had been mentioned before, it is very hard to guess what it could be called by someone else. Therefore, I apologize to Johannes Kinder for having had the “new” in the title, as it isn’t. However, I will still keep this article as it shows some more practical examples/code that helps in its understanding and execution, and is based on x64, instead of x86, which gives the programmer more “room to play”. I just wanted to credit Johannes Kinder for the original idea.</p><hr><p>You can see this technique as an improvement on what is called “impossible disassembly” which you can read about in a classic: “<a href=https://www.amazon.com.au/Practical-Malware-Analysis-Hands-Dissecting/dp/1593272901 target=_blank rel="nofollow noopener noreferrer">
<span>Practical Malware Analysis
</span></a>”, chapter 15. I’ll be showing some slightly more advanced examples and, of course, the technique itself.</p><p>In order to explain this, I’ll be going through the basics till the more advanced stuff, always explaining with code:</p><ul><li><p>Background — Linear sweep and Recursive descent</p></li><li><p>“Impossible disassembly” — the technique</p></li><li><p>Example in Windows using C</p></li><li><p>Advanced version — “jmp short -9”</p></li><li><p><strong>Assembly wrapping</strong></p></li></ul><p><strong>Disclaimer</strong>: While this technique might be used for malicious purposes, I do not condone it. The only reason I look into such techniques is that 1: they are technically interesting; and 2: as part of a Red Team, you will undoubtedly be developing your own tool arsenal and, as such, end up going deep into reverse engineering (RE) and implementing anti-RE techniques.</p><p>I will be using x64 assembly and C for proof-of-concept code. The C code will be compiled with <a href=https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/ target=_blank rel="nofollow noopener noreferrer">
<span>mingw-w64
</span></a> compiler, and if you are wondering “why aren’t you using Visual Studio?”, that would be because they (Microsoft) <a href="https://docs.microsoft.com/en-us/cpp/assembler/inline/inline-assembler?view=vs-2019" target=_blank rel="nofollow noopener noreferrer">
<span>don’t support inline assembly for x64 architecture
</span></a>. Just to be clear, this is not an incapability issue, it’s actually a choice they made for better code compiling optimization.</p><p>Also, the whole point of this blog is to show a specific anti-disassembly technique in disassemblers. But not only in the purest of forms, such as in tools like objdump or IDA, but also the disassemblers inside debuggers (e.g. x64dbg). So, while I would not intentionally compare apples and oranges, when I do mention debuggers, what I actually mean is the disassembler inside them. Also, while I do use Immunity quite a lot, it doesn’t support 64-bit PE files, so it won’t be featured here.</p><p><strong>Background — Linear sweep and Recursive descent</strong></p><p>As a beginner in RE, one tends to assume that the disassembled code shown by disassemblers (e.g. IDA, objdump) or debuggers (e.g. x64dbg, gdb) is definitive. However, that is not true, as proven by the fact that most of these tools allow the researcher to rearrange the code/data analysis.</p><p>Bottom line, the linear sweep starts from entry point / start of function and just runs through the opcodes assuming everything is code and all linear (one instruction starts after the other), while the recursive descent is smarter and follows the control flow to better distinguish between code and data. However, there’s still linear sweep when doing recursive descent, as it only stops doing the linear sweep when finding control flow instructions such as conditional jumps, absolute jumps, calls, and returns.</p><p>As an example, check the following code, with data in between. It’s not relevant here to understand all instructions, but rather the fact that there’s data (“buffer db …”) in between the code:</p><p><img src=images/01.png alt="Source code in assembly x64"></p><p>This simply prints out “Australia” in the console. If you want to know more about this code, I’ve written extensively about shellcoding (even though this is not shellcoding as it has null bytes and absolute references to the buffer memory position) in previous blogs such as <a>
<span>this one
</span></a>.</p><p><img src=images/02.png alt="compilation + execution"></p><p>The point here is to show objdump and gdb doing a linear sweep, and IDA using the recursive descent to analyze the code, so let’s see how each distinguish between code and data. Note that the “len” line will not show up as it will simply be calculated and replaced in the relevant locations — mov rdx,len — by the compiler.</p><p><img src=images/03.png alt="linear sweep with objdump"></p><p><img src=images/04.png alt="linear sweep with gdb"></p><p><img src=images/05.png alt="recursive descent with IDA"></p><p>You can clearly tell that the recursive descent (done by IDA here) is better at telling the difference between code and data.</p><p>I’d definitely recommend reading chapter 1 of “<a href=https://www.amazon.com.au/IDA-Pro-Book-Unofficial-Disassembler/dp/1593272898 target=_blank rel="nofollow noopener noreferrer">
<span>IDA Pro book
</span></a>”, 2nd Edition, or chapter 15 on “<a href=https://www.amazon.com.au/Practical-Malware-Analysis-Hands-Dissecting/dp/1593272901/ target=_blank rel="nofollow noopener noreferrer">
<span>Practical Malware Analysis
</span></a>”, chapter 15 for more on these algorithms.</p><p><strong>“Impossible disassembly” — the technique</strong></p><p>By understanding the algorithms previously mentioned, one can imagine there are a few ways to exploit the disassembly process. One such way is called impossible disassembly. The name is a bit unfortunate because it’s not actually impossible, as it is only referenced that way because of the predicament in which the disassembler will find itself: one byte belonging to two instructions.</p><p>In the following image, the disassembly you see above the hex bytes is what the disassembler will show you or “see”, but the instructions below is what it turns out to be (after the jump is made).</p><p><img src=images/06.png alt="jmp -1 algorithm"></p><p>The difficulty here (and hence the “impossible”) is a basic assumption in disassembly, which states that one byte is only interpreted in the context of one instruction. This is obviously not true, as shown above where 0xff belongs to two instructions.</p><p>Note that, after the jump, there is an increment to eax. Make sure this does not impact your hidden code! If you were messing with eax and were expecting it to be a specific value, this will change it of course. Also, you can swap the 0xc0 for something else, but you have to keep in mind that this new byte has to be the start of an instruction that will consume some of the next bytes of “real code” and only partially.</p><p>So, let’s see it in action! Using the previous assembly example, but this time printing out “Evil code!”, which will be what we’re trying to hide from the disassembler.</p><p>Let’s inject the anti-disassembly code right at the beginning of the _start entry point:</p><p><img src=images/07.png alt="source code in assembly x64"></p><p>After compiled with nasm, you can see the code is hidden, even with recursive descent:</p><p><img src=images/08.png alt=IDA></p><p>And this runs just as before:</p><p><img src=images/09.png alt=execution></p><p>Keep in mind that, as I’ve pointed out before, a reverse engineer can instruct IDA to interpret bytes/opcodes as data (pressing ‘D’) or as code (pressing ‘C’) after identifying this technique. So, this won’t stop any decent reverse engineer but might slow them down. And you can slow them down even more with the advanced variation of this that we’ll look at ahead.</p><p>Also, the “inc eax” (ff c0 executed after the jump -1) is irrelevant in this example, given that I set rax to 1 right after.</p><p><strong>Example in Windows using C</strong></p><p>Why not show a similar example but with assembly, in Windows? Because the concept is exactly the same. The only actual difference is that instead of doing the “db …” (stands for define byte) in the beginning (define byte), you’d be doing a “.byte 0xeb,0xff,0xc0” (different compilers…).</p><p>So, for our proof-of-concept, let’s use the following, and see if we can hide the “evil” part from disassemblers:</p><p><img src=images/10.png alt="source code in C"></p><p>Which then executes into the following, where you can see the “evil” code being executed:</p><p><img src=images/11.png alt="compilation + execution"></p><p>But when looking at it, using different tools, they can’t disassembly it right, at first — again, you can do this manually in both the following tools, but it requires extra work in your RE.</p><p>So, let’s look at IDA:</p><p><img src=images/12.png alt=IDA></p><p>The first “printf” (“puts”) is clearly shown but not the second “evil” code. So, the added 3 bytes do exactly what they are supposed to do.</p><p>In x64dbg, it compromises its analysis as well. A common task in RE is to search for string references and intermodular calls, and in this case, the “evil code” doesn’t show up and, in looking for intermodular calls, it only shows one occurrence of the “puts” function:</p><p><img src=images/13.png alt="x64dbg: only “hello world” shown"></p><p><img src=images/14.png alt="x64dbg: only one “puts” shown"></p><p>And, of course, the disassembled code:</p><p><img src=images/15.png alt="x64dbg: disassembled code"></p><p><strong>Advanced version: “jmp short -9”</strong></p><p>Now, just in case you’re wondering if one couldn’t simply write down a script (e.g. IDAPython) and patch that “eb ff c0” sequence by removing them, think again. While that would solve this specific problem, it wouldn’t solve the million variations that you can come up with. Also, after the CPU does the jump, it’ll execute “inc eax”, and to avoid complexity, we neglected that instruction. But one could write code right after, that would depend on that increment, or validate eax to a specific/expected value. So, you can see there’s no universal solution here. Moreover, what if we don’t just jump back one byte (jmp short -1 | eb ff) but, instead, jump 9 bytes back?</p><p>Let’s see such an example:</p><p><img src=images/16.png alt="jmp -9 algorithm"></p><p>To understand this image, read the code as disassembled above the hex code, and then after the “jmp” backwards (-9), read the code below the hex code, which will be hidden from the disassembler.</p><p>What you’ll see in the disassembler is:</p><p><img src=images/17.png alt="disassembled code"></p><p>The jump (right before the last instruction call) will go backwards and land the CPU (rip) right in the “middle” of the data I first put into rax, in the eb 08 part to be more precise, which is another jmp but ahead, right after the e8. The e8 is important here because it’s the start of a call instruction and will consume the next bytes as a memory address (as function/code memory location) and will, therefore, hide the instructions that those bytes actually represent. And that’s why the “jmp” ahead (eb 08) lands right after the e8 (fake call).</p><p>Let’s see it working then:</p><p><img src=images/18.png alt="C code"></p><p><img src=images/19.png alt="compiled + executed"></p><p><img src=images/20.png alt=x64dbg></p><p><img src=images/21.png alt=IDA></p><p>The other interesting thing is that, because of the nature of this code, the ff’s are quite irrelevant. So you can replace them with any other bytes and it would still work. Ideally, if you have different variations on the same executable, it would make it harder to automate detection and elimination, through scripting, of these byte sequences in the code.</p><p><strong>Assembly wrapping</strong></p><p>So the previous code has something interesting about it: it jumps back into a large instruction (mov rax,…) and executes code that is inside the value you’re putting into rax. The ff’s are quite irrelevant but, what if they weren’t? What if I could build a “skeleton” code where I could then place hidden code instead of the ff’s? This is what I came up with:</p><p><img src=images/22.png alt=skeleton.nasm></p><p>The hidden code execution will be triggered by the jmp instruction. The values are reversed (little-endian), but what’s happening here is a jump back to the first byte of the 8-byte value placed in rax, which will be (in the correct order) “ff ff ff ff ff ff eb 04”. Now, all ff’s will be replaced with my real/hidden code which will be executed, and then the “eb 04” is simply a jump ahead into the start of the next 8-byte value placed into the next “mov rax,…”, which will again execute the code that will be placed there until it reaches the “eb 02” which, again, jumps ahead into the next hidden instruction.</p><p>Before writing up code to be hidden inside this skeleton, we must acknowledge some <strong>limitations</strong>:</p><ul><li><p>Given the fact that I chose the “mov rax,…” (a 10-byte instruction) as my “skeleton”, none of the hidden code’s instructions must be longer than 6 bytes. This is because the bytes/opcodes on a single instruction must be placed right next to each other when being read by the CPU, and I only have 6 available, given that “mov rax,…” is made of 2 bytes that identify the instruction, and 8 bytes to put in the register. I still need to take on 2 of these 8 bytes for the “jmp short 2 / eb 02”, so I’m left with 6 bytes to play with. However, I can still join instructions together, as long as the total number of bytes doesn’t exceed the number 6. And you’ll also notice that I sometimes have to “pad” (encryption term) the instructions when they’re shorter than 6 bytes with NOPs (0x90), otherwise, the compiler nasm will have null bytes appended to the higher end of the 8-byte value.</p></li><li><p>Given the previous point, you can now understand why I can’t write this in C, as you’ll definitely have the C compiler throw assembly code with instructions longer than 6 bytes at you. So I need full control on writing the assembly, which forces me to write it myself.</p></li></ul><p>I’ll mention the advantages after the example as you’ll understand my point better.</p><p>So the code we wish to hide is the following:</p><p><img src=images/23.png alt=code.nasm></p><p>This is not as simple or straight-forward as the previous assembly codes I’ve shown, because this is more like actual shellcode, while still just printing something — “Evil\n” — out on the command line. I chose to do this, this way because I want to:</p><ul><li>have as short instructions as possible to fit the most inside those 6 bytes, in a single “mov rax,…”.</li><li>have no null bytes, again to save on space.</li><li>need position-independent code as absolute memory positions will change once placed inside the skeleton code.</li></ul><p>These are all characteristics of shellcode, which I’ve written extensively about in my <a href=https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/ target=_blank rel="nofollow noopener noreferrer">
<span>previous blog
</span></a> so I won’t delve into the details of the code, but suffice to say it simply prints out “Evil\n”:</p><p><img src=images/24.png alt="compilation + execution of hidden code to produce opcodes"></p><p>The executable has the following opcode:</p><p><img src=images/25.png alt="objdump with opcode of compiled code.nasm"></p><p>Notice that there are, as in previous examples, two syscalls: the write to stdout file descriptor and the exit (process). Without this last one, the process breaks (rip is incremented out of the .text memory section and tries to execute data in memory where it has no permissions to execute) and you’ll see an error being shown.</p><p><img src=images/26.png alt="exit syscall commented out"></p><p><img src=images/27.png alt="segmentation fault due to not properly exiting the process"></p><p>This is interesting because, as you’ll see ahead, the skeleton itself doesn’t properly exit the process, so it should crash. However, it doesn’t actually crash, because the actual code it’ll be executing does exit properly.</p><p><img src=images/28.png alt="Final skeleton code"></p><p><img src=images/29.png alt="Hidden code executed from within the skeleton"></p><p>Success!! And the disassemblers will simply show the skeleton and not the hidden code:</p><p><img src=images/30.png alt="disassembly by objdump"></p><p><img src=images/31.png alt="disassembly by IDA"></p><p>Now while this specific example is very easy to recognize as an anti-disassembly technique (a first mov rax,… then a jmp -x, and a never-ending sequence of mov rax,…), you have to consider its flexibility. If you spread the movs further (even though no longer than 256 bytes as per the relative jump: “jmp short”) and place other code (that will simply never be executed) in between, you can make this look a lot like something else completely benign, which could be a <strong>huge advantage</strong> in hiding the real code. <strong>Another advantage</strong> is the fact that this is a pain to manually instruct the disassembler on how to interpret the code/data. So you’d have to end up writing some plugin to help you if the hidden code is large (albeit shellcode), which could be very tricky if you think about the fact that you’ll have to automate the distinction between real “mov rax,…” instructions and the “wrappers”.</p><p>Also, you can choose longer instructions as wrappers, which will give you more space, per line/instruction to fit in your hidden code.</p><p>So, there you go. I hope you found it as interesting as I did.</p></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div></main><footer class=footer><span>&copy; 2020 Andre Lima</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/gokarna-theme/gokarna-hugo>Gokarna</a></span></footer></body></html>